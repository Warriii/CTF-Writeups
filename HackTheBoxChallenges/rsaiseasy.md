### RSAisEasy
---

#### Files
`RSAisEasy.py`
```py
#!/usr/bin/env python3
from Crypto.Util.number import bytes_to_long, getPrime
from secrets import flag1, flag2
from os import urandom

flag1 = bytes_to_long(flag1)
flag2 = bytes_to_long(flag2)

p, q, z = [getPrime(512) for i in range(3)]

e = 0x10001

n1 = p * q
n2 = q * z

c1 = pow(flag1, e, n1)
c2 = pow(flag2, e, n2)

E = bytes_to_long(urandom(69))

print(f'n1: {n1}')
print(f'c1: {c1}')
print(f'c2: {c2}')
print(f'(n1 * E) + n2: {n1 * E + n2}')
```

`output.txt`
```
n1: 101302608234750530215072272904674037076286246679691423280860345380727387460347553585319149306846617895151397345134725469568034944362725840889803514170441153452816738520513986621545456486260186057658467757935510362350710672577390455772286945685838373154626020209228183673388592030449624410459900543470481715269
c1: 92506893588979548794790672542461288412902813248116064711808481112865246689691740816363092933206841082369015763989265012104504500670878633324061404374817814507356553697459987468562146726510492528932139036063681327547916073034377647100888763559498314765496171327071015998871821569774481702484239056959316014064
c2: 46096854429474193473315622000700040188659289972305530955007054362815555622172000229584906225161285873027049199121215251038480738839915061587734141659589689176363962259066462128434796823277974789556411556028716349578708536050061871052948425521408788256153194537438422533790942307426802114531079426322801866673
(n1 * E) + n2: 601613204734044874510382122719388369424704454445440856955212747733856646787417730534645761871794607755794569926160226856377491672497901427125762773794612714954548970049734347216746397532291215057264241745928752782099454036635249993278807842576939476615587990343335792606509594080976599605315657632227121700808996847129758656266941422227113386647519604149159248887809688029519252391934671647670787874483702292498358573950359909165677642135389614863992438265717898239252246163
```
#### Writeup

We notice from glancing at the source code that the flag is split into two messages. Both of which are then separately encrypted with RSA over two different moduli, $n_1 = p*q$ and $n_2 = q*z$ for some primes $p, q, z$. The encrypted outputs, $c_1$ and $c_2$, are provided, alongside a cryptic $(n_1 * E) + n_2$. We note that the exponent $e$ used in the encryption is $65537$.

In lieu of brevity I will not directly cover and go in depth into how RSA operates or the math behind it. Feel free to google, or check out my `WxM` 2024 ctf writeup on the challenge `Crypto 2 - Common Faults` which goes deeper into the theory! You can find this in the same github `CTF-Writeups` repository.

Essentially, in order to decrypt the RSA-encrypted $c_1$, $c_2$, we can try to recover the prime factorisation of $n_1$ and $n_2$ respectively. We can then compute the Euler-totient $\phi(n_1) = (p-1)*(q-1)$ for $n_1 = p*q$, then find the multiplicative inverse of $e$. We can thus RSA encrypt $c_1$ with that inverse to reverse the effects of raising the mesaage to the $e^{th}$ power, recovering the plaintext!

Since $n_1, n_2$ share $q$ as a prime factor, it follows that $(n_1 * E) + n_2$ for some $E \in \mathbb{Z}$ also contains $q$ as a prime factor. We can compute the greatest common divisor (`gcd`) of $n_1, (n_1 * E) + n_2$ to recover $q$. We then recover $p = n_1 / q$.

Assuming $n_2 < n_1$, we can derive $n_2 = ((n_1 * E) + n_2) \bmod n_1$. Then we have $z = n_2 / q$, giving us all that we need to decrypt $c_1$ and $c_2$! Even if $n_2 > n_1$, because $n_2, n_1$ are 1024-bit values, at most $3*n_1 > n_2 > n_1$, so it is very easy to derive $n_2$ regardless of whether its greater than or less than $n_1$.

#### solve.py
```py
n1 = 101302608234750530215072272904674037076286246679691423280860345380727387460347553585319149306846617895151397345134725469568034944362725840889803514170441153452816738520513986621545456486260186057658467757935510362350710672577390455772286945685838373154626020209228183673388592030449624410459900543470481715269
c1 = 92506893588979548794790672542461288412902813248116064711808481112865246689691740816363092933206841082369015763989265012104504500670878633324061404374817814507356553697459987468562146726510492528932139036063681327547916073034377647100888763559498314765496171327071015998871821569774481702484239056959316014064
c2 = 46096854429474193473315622000700040188659289972305530955007054362815555622172000229584906225161285873027049199121215251038480738839915061587734141659589689176363962259066462128434796823277974789556411556028716349578708536050061871052948425521408788256153194537438422533790942307426802114531079426322801866673
hint = 601613204734044874510382122719388369424704454445440856955212747733856646787417730534645761871794607755794569926160226856377491672497901427125762773794612714954548970049734347216746397532291215057264241745928752782099454036635249993278807842576939476615587990343335792606509594080976599605315657632227121700808996847129758656266941422227113386647519604149159248887809688029519252391934671647670787874483702292498358573950359909165677642135389614863992438265717898239252246163

from math import gcd
q = gcd(hint, n1)
p = n1 // q
n2 = hint % n1
z = n2 // q

def rsa_decrypt(p,q,ct):
    d = pow(0x10001, -1, (p-1)*(q-1))
    m = pow(ct, d, p*q)
    return m.to_bytes((m.bit_length() + 7) // 8, "big")

m1 = rsa_decrypt(p,q,c1)
m2 = rsa_decrypt(q,z,c2)
print(f'{m1 = }')
print(f'{m2 = }')
# b'HTB{1_m1ght_h4v3_m3ss3d_uP_jU$t_4_l1ttle_b1t?}'
```