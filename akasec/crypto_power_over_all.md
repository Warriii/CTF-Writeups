## Power Over All 

```py
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes
from random import randint
from SECRET import FLAG

def key_gen():
    ps = []
    n = randint(2,2**6)
    for _ in range(n):
        p = getPrime(256)
        ps.append(p)
    return ps

def encrypt(m, ps):
    ps.sort()
    for p in ps:
        e = 1<<1
        m = pow(m, e, p)
    return m

if __name__ == "__main__":
    ps = key_gen()
    c = encrypt(bytes_to_long(FLAG), ps)
    print('ps = {}\nc = {}'.format(ps, c))
```

We can derive the equation, given `ps = [p0, p1, p2, ..., pk]`:

`c = pow(...pow(pow(pow(m, 2, p0), 2, p1), 2, p2), ...., 2, pk)`

Normally in standard RSA, we know that given any `m**e % n`, we compute the euler totient of `n`, then compute `d = pow(e, -1, phi(n))`. This leads to the result that `(m**e)**d = m**(ed) == m**(1 + k*phi(n)) == m**(1) % n` for some integer value k. Note that the euler totient has the property where for any coprime `m`, `m**phi == 1 mod n`.

Consider the case of `c = pow(m, 2, pk)`. Since `pk` is prime, by definition the euler totient is `pk - 1`. But one would notice that `pow(2, -1, pk-1)` fails. Python breaks because the whole `e` and `d` and `phi` concept relies on the fact that `e` and `phi` are coprime with each other; Since `pk` is odd (otherwise `2` would be a factor), `pk - 1` will have a factor of `e = 2`.

Rather, we should not tunnel vision into the problem of RSA, but rather the (just as well-established) problem of finding modular square roots; That is, given a `quadratic residue` m mod n, find solutions x such that `x**2 % n == m`. A `quadratic residue` represents the fact that there will exist a solution `x`. Normally when the modulus is a composite number, it would be a difficult problem to solve much like RSA's problem of integer factorisation; On the other hand, since all of our moduli are the primes `{p0, p1, ..., pk}`, much like factorising a prime, finding the modular square root is trivial.

[cryptohack.org](https://cryptohack.org/courses/) covers this decently with their Modular Arithmetics course, and we can implement various algorithms such as Tonneli-Shanks to solve. We'll be using Sagemath which has already implemented the algorithm for us. Note that for every solution `x mod n` found such that `x**2 mod n == m`, `-x % n` is also a valid solution.

Moving backwards from `pk`, we'll find all possible solutions that would result in `c`. We'll then move to the next prime, further narrow possible solutions, and repeat.

One might question whether or not they'd exist `2^k` possible solutions for `k` primes, and with `len(ps) == 55` might be concerned about this being infeasible. In truth however, since for every quadratic residue `m` there exists two modular square roots, naturally about half of every number from `1` to `n` will be quadratic residues. Thus, even though each valid `m` we find results in double the possibilities, some of them, when subjected to the next modulus, might be `non-quadratic residues`, thus we can eliminate these possibilities to offset the doubling. I'll use `legendre's criterion` to test each value on whether it is a `quadratic residue`, which can be derived through a bit of Group Theory and Lagrange's Theorem. Alternatively, those who are familiar with the `pohlig-hellman` algorithm for solving the `discrete logarithm problem`, a separate cryptographic primitive, might be able to derive the criterion themselves.

After 55 rounds, we'll end up with a few solutions, of which one of them must be the flag.


`solve.py`
```py
from sage.all import *

# from provided out.txt
ps = [58320376514263631335873677765253125888698486914776244278840394907785982174227, 58471100903556849464997941473361218814224259836954194397969653104598610032001, 58604272362819290182402155417145974680722885151257754555756391392263925028373, 59492683945798085501800206338526899942899780311409115479365237372756535853291, 62289703300031234585435188246756616897767167359387015636210423567810538226487, 62357776874227535169229603723986677552237575016029450363623522209118965731477, 62742816090727067053274726868556821524033631101402012261515152539681610794161, 63324484395885397762900693586081837883926106660748610230948918800296364184787, 68536318595052838310834810610435117143127088803068602445335475326427140828313, 71333662629967127822322169475282958517332768085026414016527475771426692311137, 71818789628596987832122424763592924131858666988566206124807910367000034628553, 72686903390659724206544737536831534683324964478965218565533472954938736006029, 73733187867854099083339033682720615801689502367745526033697746193463091215391, 74963435458999407861524268290816092282448161750409920047891056819453141955557, 75170120333127044486222669300167892338904422362667312672451826995740967131303, 75389546402724552962462061186170732933053151602764277596760332277139980288183, 76425604829327821607866318415668087016313389323090875428602763671306466213509, 79395489525333852455993920714320320052245084253382013156160044439065839468327, 79656464249999345933529538948250990091001499735972420522175125449790253663599, 80114644787477907454032975169773036722948929091396695518111556258640245353257, 80759006745106776887940527633196344281100618167707846074299752297932178679679, 82874221581479658193940394796733443765246468888210669340444752189895488345711, 84468817045619298841099296118053247701538652785316191917289525698631379587559, 85092225008500173289712181614303627906592443829912221851650912999596788670459, 85263141959763159396039844302970550543465193325499728803392808980592668472247, 85317220893586781914729151221061742320435924332561513947650447739620101821641, 85440269113801669657707134806659364077593365787015642755204798072592063745773, 85527879261087022928016922730880335213911499029647505445360684307006839178647, 85605932852710450456174796386471227136632343649286364769039469217779231567929, 86107819754589869545139506654865763056227887269808133233781131410193748463851, 86163843486640208219217644606617383296879865315755352427047957187159788303323, 90506049416840638351240993555664643907544570698557428055802715993870286417397, 90981593208992230235747480738729958015954461329514397574562251177250355618859, 94292491231252601103954494535972386523808989201770556967497120902651386194197, 94647786177270050686880223709072304737527824812798720504615370320158513996239, 95245024143291248356010627064844329722889005501412707859257139919568967846749, 96080930363425942206733690433078387012542225534990227081492087888246704507441, 97503025379673346416669602471064834261095444529417927406127397664552811080519, 97933089652660434994459543027801105444314465759238615625507952727940600189809, 97989967696425430412414365007330195727579540568089381507635553281304266294483, 98528881400840757343372680020873216862352604380253902505512625033610753437887, 99954243543097817759175467071884308315066389399425962144138323810271659014209, 101194437697606745792831239895049471075868629243259633705095039109106669730049, 104839585136982979038455371159792466832240349600316352323298553695087849421381, 105456177698115744366058226841117004148984862640508652026693415913601327156663, 105968680258458596148231537242426487615777154901757802179920828015643162453013, 107215231310505428676141499322854084705449980120508349014281658724461432400217, 108453510226000323101878638579711809016925129461454736081626840494612032349563, 108912309872075893365304953396355888979232521108447384367848671194555817947569, 108997022694208058790012872910875462503431062529475661062287324154956518493253, 109322568022936420513907683387388159609608845110397725890561824119551381299491, 110029910646386857435917200277309270534213159892118369614262345955187628998231, 113144116692201726589659464242284454643667198002480615110504233499994524508369, 114364819674774846158222033218389865879337160752260853195966728903452922982539, 115473149458023487534963694928189868221104180303262395583076896364124371580681]
c = 53630975642867707857977893429296334474716191527562307357222551886495223105860
e = 1 << 1
cs = [c]
cnt = 0
for p in ps[::-1]: # start from pk and work all the way to p0

    ccs = []
    for c in cs:

        if int(pow(int(c), (p-1)//2, int(p))) != 1: 
            # legendre symbol to check for quadratic residue; If absent, we skip the value as there is no solution
            continue

        val = int(sage.rings.finite_rings.integer_mod.square_root_mod_prime(Zmod(p)(c), p))  
        if val**2 % p != c: # quick test
            continue
        ccs.append(val % p)
        ccs.append((-val) % p)

    cs = ccs[::] # copy ccs over to cs
    cnt += 1
    print(f'{cnt}/{len(ps)}, ccs length is {len(cs)}') # tracking purposes

for c in ccs:
    flag = long_to_bytes(c)
    if b'AKA' in flag:
        print(flag)
```

`out`
```js
1/55, ccs length is 2
2/55, ccs length is 4
3/55, ccs length is 6
4/55, ccs length is 4
5/55, ccs length is 2
6/55, ccs length is 2
7/55, ccs length is 4
8/55, ccs length is 2
9/55, ccs length is 2
10/55, ccs length is 2
11/55, ccs length is 2
12/55, ccs length is 4
13/55, ccs length is 8
14/55, ccs length is 12
15/55, ccs length is 14
16/55, ccs length is 14
17/55, ccs length is 16
18/55, ccs length is 14
19/55, ccs length is 12
20/55, ccs length is 14
21/55, ccs length is 16
22/55, ccs length is 16
23/55, ccs length is 18
24/55, ccs length is 14
25/55, ccs length is 14
26/55, ccs length is 14
27/55, ccs length is 18
28/55, ccs length is 14
29/55, ccs length is 10
30/55, ccs length is 8
31/55, ccs length is 8
32/55, ccs length is 10
33/55, ccs length is 12
34/55, ccs length is 12
35/55, ccs length is 8
36/55, ccs length is 10
37/55, ccs length is 14
38/55, ccs length is 18
39/55, ccs length is 20
40/55, ccs length is 26
41/55, ccs length is 34
42/55, ccs length is 34
43/55, ccs length is 34
44/55, ccs length is 38
45/55, ccs length is 42
46/55, ccs length is 44
47/55, ccs length is 40
48/55, ccs length is 40
49/55, ccs length is 38
50/55, ccs length is 36
51/55, ccs length is 36
52/55, ccs length is 34
53/55, ccs length is 44
54/55, ccs length is 54
55/55, ccs length is 60
b'AKASEC{akasec+palestine=<3}'
```