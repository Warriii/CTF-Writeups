### Intro to RSA 2 | 21 Solves 964 Points
```
More math for you!

Author: hadnot
```

`rsa-school-2.py`
```py
from Crypto.Util.number import isPrime, bytes_to_long
import secrets

with open("flag.txt", "r") as f:
    flag = f.read()
    
def genPrime(bits):
    while True:
        x = secrets.randbits(bits - 1000)
        p = (x<<1000)+1
        if isPrime(p):
            return p
        
p = genPrime(1024)
q = genPrime(1024)
N = p*p*q*q*q

m = bytes_to_long(flag.encode())
c = pow(m, e, N)

print(f"{N = }")
print(f"{c = }")
```

The challenge code is quite straightforward. We are given our RSA modulus `N = p^3 * q^2`, and an encrypted flag `c`. We also know that `p`, `q` are generated using a strange `genPrime()` function, which involves generating random 24-bit `x` and testing if `x << 1000 + 1` is prime. (Note `<<` is bit shift left, which is the equivalent of multiplying a number `x` by 2).

So we have `p`, `q` which are `24-bit_unknown * 2^1000 + 1`. 24 bits is decently brute forceable to find our `p` and `q`, thus allowing us to perform regular RSA decryption to obtain the flag. Once we find `p` (or `q`), we use python's `gmpy2.iroot` to perform square or cube root to obtain the other prime factor.

It should be noted that to compute the order, we don't do `(p-1)*(q-1)`, but rather follow the formula that is Euler's totient function. Given N = p^3 * q^2, its order would be `p^2*(p-1)*q*(q-1)` instead.

```py
from sage.all import PolynomialRing, Zmod, inverse_mod
from gmpy2 import iroot
N = 99058767323098132264276802451827925525332544745603430685881744977580652821117472487099985953328415858215805001618570996599978690474297870103995006672307575218212582483293351341765550498712425339193474995059309437245655862755205623197145742170094547523686387824035833435889358840643606170243228232304472987433623437714069999825516864459738005321421367942868831513492521127465864697518371694932843308787806486838906269364989367482871443017768069944950539824325485223474071732165839302129232992674143794873284240934000504776230592388732780375157362788377472413470273172396162243469332991143430019877160908110480174735001370348608004970135479272187172673291153291237469861817566478831663967906936623129032654566887825999787415897437603111777305574134517467091492942275116978870847493369043375755810652460457007038723856767004027292042970542035394164860786258992255724739953418395388279422355001377769744414695316706925785195351213685963452100582228150244656914745135538714187559286784022282380732387615886832512468486327316890803707959384837607446261971007621772858511638932588899245154336575534816342268531820594614888984680995581827025723483056679241112705128325027984265259790590753009234027059180131287177265271236847123748543670892425078513563511199021870015027627280902172285759705675273821919059863781588585490928750652458806543159996733530050726266837003060090784048005032946874275653354455690507206694736815128325405296457464965362217613150461052461807644599546019198837562143779993819231895410093456942147659735695290515912793461358593
c = 58556544128869678166582759221068083300567870239093714763816282685353782162097789207572446940754363912882970739077079617508174686166742854515474412644384136503428553392878272280292148603530641391587122494252601673322593045583443417259140833334149337673179593221587401664956962744950915649321834224553091508033303737437042320977674325450287810726815146812003357745906015328499781585666709033781056097636809314191502487191112001284815938623837204483923477360344541998809264388271441760185679235182181307148582538990029126982565707770700767295544671978948125480227218659270290117840139067744906510376834065611259637043464857470412232038189517036129100027609073142334657954650768907084125040124598249064726182479813089814275609125986145536319074032385544262818824015710792004975737614816043088783473163738967322403586901403683198767107226120981719524516125596563716865390696419978549216134351972911736972206269341420140296447796661847568225346284679680635335631648435591680213360052895963148733820775438523298719348965301271834859304021649513962744601374145373601234211774200745344985951961445496093218880532656358312413322276835511647857232972074188362687680803767968642644680839232994975351787198247363755869514146763432314508616956536878668310429089118528565260837701044195328071360357225583983480764366292328309974038348998344366725669093335052074386911770689681115854844966570756204952194260905714740883158043039112214100666051896822736087030664375061485448629825868979002490950193345688141774486582796743176549858425354706579162988546287883
e = 0x10001

from tqdm import trange
for msb_p in trange(1, 2**24):
    p = (msb_p << 1000) + 1
    if N % p == 0:
        print(f'{p = }')
        break
# p = 138459656455100864001870077847502035559585970469509561212372661184968205801691525789452698863601776741898581973815550398736714794044177977632804808407290202907655032973941124042828059097841235903593843752714008754763446895813085760878413372276395258050062468328090925951809344017105986558749614061629720231937
q = int(iroot(N // p // p, 3)[0])
m = pow(c, inverse_mod(e, q*q*p*(p-1)*(q-1)), N)
print(m.to_bytes(64, "big").lstrip(b'\x00'))
# grey{c0ngr4ts_y0u_kn0w_brut3_f0rc3}
```

### Small Roots

An alternative method to do this in much quicker time is to use Coppersmith's method to find a small root. As we have a prime that takes the form of `x * 2^1000 + 1`, we use this as a polynomial. Since this polynomial is 0 modulo a prime factor of `n`, we use sage's `.small_roots()` functionality to find the root `x`. We just need to mess with the `X` and `beta` input parameters, as per reading sagemath's `.small_roots()` documentation [here](https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots)

```py
from sage.all import PolynomialRing, Zmod, inverse_mod
N = ...
c = ...

# This line of code essentially defines polynomials using `x` as their unknown to be in the ring of integers modulo N. That is, any f(x) will output values modulo N
F = PolynomialRing(Zmod(N), names=('x',)); (x,) = F._first_ngens(1)

# Function used to denote our prime. This value will be 0 modulo a prime factor of N
f = (x * 2**1000) + 1
f = f.monic() # Convert to a monic polynomial for small_roots()

# Run small roots and recover p, q
p,q = [root*2**1000 + 1 for root in f.small_roots(X=2**25, beta=0.1)]
assert p*p*q*q*q == N

m = pow(c, inverse_mod(e, q*q*p*(p-1)*(q-1)), N)
print(m.to_bytes(64, "big").lstrip(b'\x00'))
# grey{c0ngr4ts_y0u_kn0w_brut3_f0rc3}
# ...and coppersmith small_roots() now! :D
```