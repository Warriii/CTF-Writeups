### Intro to RSA 3 | 19 Solves 961 Points
```
More math for you!

Author: hadnot
```

`rsa-school-3.py`
```py
from Crypto.Util.number import isPrime, bytes_to_long
import secrets


with open("flag.txt", "r") as f:
    flag = f.read()
    
def genPrime(bits):
    while True:
        x = secrets.randbits(bits - 600)
        p = (x<<600)+1
        if isPrime(p):
            return p
        
p = genPrime(1024)
q = genPrime(1024)
N = p*q
e = 0x10001
m = bytes_to_long(flag.encode())
c = pow(m, e, N)

print(f"{N = }")
print(f"{c = }")

sm = (N&((1<<1100) - 1)) + 1
print()
print(p+q)
print(sm)
```

A strange thing to note is that while this script allegedly prints `N`, `c`, and `p+q` and `sm`, we are only given `N` and `c`. This is a little bit suspicious, so let's look into it!

The first thing to note is that `p`, `q` follow a `genPrime()` function that uses 424 unknown bits to generate a prime. So we can view `p`, `q` as `_p * 2**600 + 1` and `_q * 2**600 + 1` respectively, with `_p` and `_q` being our smaller 424-bit unknowns.

Multiplying these two values we find;

```py
N = 2**1200 * _p * _q + 2**600 * (_p + _q) + 1
```

Now, because `_p` and `_q` are 424-bits, `_p + _q` is at most 425 bits. Thus, `2**600 * (_p + _q)` is at most 1025 bits which is much less than the 1200-bit `2**1200`. As this latter value is multiplied with `_p` and `_q` to find `N`, the upper bits of `N` up till the 1200 bit is essentially `_p*_q`, whereas the lower 1200 to 600 bits is `_p + _q`.

You can actually see this when you look at `N` in binary.
```py
>> N = 4425251209709031359523200849630225760169157607374213664235644753699880558114318935786999245805186334767623050620917674996437834795771435460148325603940016149303098176881592391800272450994806535968711016297529508003554814502839060614107036346788307383544498504520556013163476365728285719071588657494313215433254361244339176679711052587368657390212501574375893590612924106919921059278110602965098451029141560566812945151109640657457339915205112997178265653647607697865358620221381836523188202812572912556253653250603124765152247419648091319013485146809201331198775534091911694898728081340038103596994511309571075604481
>> format(N, "2048b")
'100011000011100000001110010010001011000100111011010101100011011101010000111100100001001101011010110000100110111011011110010000101110011011101010111110101110000000001001010011001110010100001011100011010010101101101100110101111010000111010110100001110100011000111011101011000111010100101100110101000010110010101011100110100000111100010101001100101010100100011011000011010111111000011100101000011000110010000101110010011011110000111111100111001000010001011000000101010110110110001110010111111101001100101110101111110011001010100000000010110110101100011010100000101001101101010000011101111001010101100001101011000010001111000011010000001000110110010101111001011000101101101010000001001111101010001110001001000110000111111011100000010010110010110010000001001101100101001100110011000010111011001011000111111001011101101001011000101110010110001000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001100001110000010111111001111111110110001111001110000101101000110011100011001101101111010100011000000101010011100110111000110110100110000100100011010111101111110101111001011001000001011000110101010111011001011001110010010000011010000111100010010101000001101111010011010101000111010100111111101111100001110110100001111101111010101001101010110100110011110110011110001000110000000000011111110110110000010100111000100011000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001'
```

Notice the long `0...0` strings in that segment 3 distinct portions of `N`'s binary output from one another. They represent `_p * _q` and `_p + _q`.

We use this to extract out `_p + _q` and `_p*_q`, getting us the equations;
```py
_p + _q == 0b1100001110000010111111001111111110110001111001110000101101000110011100011001101101111010100011000000101010011100110111000110110100110000100100011010111101111110101111001011001000001011000110101010111011001011001110010010000011010000111100010010101000001101111010011010101000111010100111111101111100001110110100001111101111010101001101010110100110011110110011110001000110000000000011111110110110000010100111000100011000000010

_p * _q == 0b100011000011100000001110010010001011000100111011010101100011011101010000111100100001001101011010110000100110111011011110010000101110011011101010111110101110000000001001010011001110010100001011100011010010101101101100110101111010000111010110100001110100011000111011101011000111010100101100110101000010110010101011100110100000111100010101001100101010100100011011000011010111111000011100101000011000110010000101110010011011110000111111100111001000010001011000000101010110110110001110010111111101001100101110101111110011001010100000000010110110101100011010100000101001101101010000011101111001010101100001101011000010001111000011010000001000110110010101111001011000101101101010000001001111101010001110001001000110000111111011100000010010110010110010000001001101100101001100110011000010111011001011000111111001011101101001011000101110010110001000000001
```

We can use the first equation to get an expression for `_p` in terms of `_q`, substitute it into the second to get a quadratic equation. We solve this equation and use the quadratic formula to obtain roots for `_q`, which are -

```py
20626544140519458048186208996455818324525009551342298880770268501952543272347128639306643769409927772225005175023152271943805345
and
12459960403574442760680076072517461839690989634762985705403943102167780588512817255218616508797039560689286685489961018472537185
```

Without loss of generality we let one of them be `_q` and the other as `_p`, and perform standard RSA decryption.

```py
from Crypto.Util.number import long_to_bytes

p, q = [(i << 600) + 1 for i in (20626544140519458048186208996455818324525009551342298880770268501952543272347128639306643769409927772225005175023152271943805345,12459960403574442760680076072517461839690989634762985705403943102167780588512817255218616508797039560689286685489961018472537185)]
c = 2853099256671009276445228600866212070084314040911010134515891834577026493749890037386288984895707146786721246411401422754320257244788848724740371484205430464846539057823475003225520671101721269552623519470311554126554145150507792383009504925314323315742972488001774512998311007015042051148408269203262684187177563624237476725165855237033460703896056779093790419605233928866615548800213130518340764278222511690618087556009019805195045720563038189195129617422885995447892522032172192876386708850300224648629471068186500147093521183921935514937990221818215793847194734106767391320630862232306317506849170872389985314521

d = pow(0x10001, -1, (p-1)*(q-1))
m = pow(c, d, p*q)
print(long_to_bytes(m)) # b'grey{w0w_m4th_15_50_fun}'
```

### Small Roots

An alternative solution would be to notice that the primes p, q are essentially 424-bit unknowns in a polynomial `x * 2**600 + 1`. We apply Coppersmith's method as before in [RSA 2](crypto_intro_to_rsa_2.md) to recover our primes and thus, the flag.

```py
from sage.all import PolynomialRing, Zmod
N = 4425251209709031359523200849630225760169157607374213664235644753699880558114318935786999245805186334767623050620917674996437834795771435460148325603940016149303098176881592391800272450994806535968711016297529508003554814502839060614107036346788307383544498504520556013163476365728285719071588657494313215433254361244339176679711052587368657390212501574375893590612924106919921059278110602965098451029141560566812945151109640657457339915205112997178265653647607697865358620221381836523188202812572912556253653250603124765152247419648091319013485146809201331198775534091911694898728081340038103596994511309571075604481
c = 2853099256671009276445228600866212070084314040911010134515891834577026493749890037386288984895707146786721246411401422754320257244788848724740371484205430464846539057823475003225520671101721269552623519470311554126554145150507792383009504925314323315742972488001774512998311007015042051148408269203262684187177563624237476725165855237033460703896056779093790419605233928866615548800213130518340764278222511690618087556009019805195045720563038189195129617422885995447892522032172192876386708850300224648629471068186500147093521183921935514937990221818215793847194734106767391320630862232306317506849170872389985314521

F = PolynomialRing(Zmod(N), names=('x',)); (x,) = F._first_ngens(1)
p, q = [int(i * 2**600 + 1) for i in (x * 2**600 + 1).monic().small_roots(X = 2**(1025-600), beta=0.2)]
m = pow(c, pow(0x10001, -1, (p-1)*(q-1)), N)
print(m.to_bytes(64, "big").lstrip(b'\x00')) # b'grey{w0w_m4th_15_50_fun}'
```